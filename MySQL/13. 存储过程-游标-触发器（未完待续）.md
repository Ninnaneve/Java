# 存储过程stored procedure
对于SQL编程而言，存储对象是数据中的一个重要的对象，它是一组为了完成特定功能的SQL语句集，在经过一次编译后，再次调用就**不需要重复编译**，因此执行效率高。
函数和存储过程有以下异同点：
- 相同点：
  - 都是为了可重复地执行数据库SQL语句的集合
  - 经过一次编译后可直接执行
- 不同点：
  - 语法中实现的标识符不同，procedure和function
  - 存储过程在创建时**无返回值**，而函数在定义时**必须设置返回值**
  - 存储过程没有返回值类型，且不能将结果直接赋值给变量；而函数定义时需要设置返回值类型，且在调用时必须将返回值赋值给变量
  - 存储过程必须通过**CALL**进行调用，不能在SELECT语句中调用；函数在SELECT语句中调用

## 定义存储过程
``` mysql
-- 定义
create procedure 存储过程名(参数1, 参数2, ...)
[存储过程选项]
begin
存储过程语句块;
end;

-- 调用
call <procedure_name>(para1, ...);

-- 删除
drop procedure <procedure_name>;
```
参数: 每个参数由3部分组成，分别为输入输出类型、参数名称和参数类型，[IN | OUT | INOUT] 参数名称 参数类型
- IN表示输入参数，即参数是在调用存储过程时传入到存储过程里面使用，传入的数据可以是直接数据，也可以是变量。
- OUT表示输出参数，初始值为null，它是将存储过程中的值保持到out指定的参数中，返回给调用者。
- INOUT表示既可输入也可输出的参数，即参数在调用时传入到存储过程，同时在存储过程中操作之后，又可将数据返回给调用者。

存储过程选项:
- language sql：说明存储过程体由SQL语言组成
- [not] deterministic：存储过程的执行结果是否确定
  - deterministic: 相同的输入对应相同的执行过程和结果
  - not deterministic: 相同的输入可能得到不同的输出（默认情况）
- sql选项
  - contains sql：包含SQL，但不包含读或者写数据的语句，默认情况
  - no sql：不包含SQL
  - reads sql data：包含读数据的SQL语句
  - modifies sql data：包含写数据的SQL语句
- sql security 
  - definer：只有定义者有权执行
  - invoker：调用者可执行
- comment  '注释'

例如，创建一个新表test_table，然后构建一个存储过程，实现把一定数量的数据插入到一个表中
``` mysql
-- 创建新表
USE purchase;
CREATE TABLE test_table (id INT PRIMARY KEY AUTO_INCREMENT,
    a VARCHAR(10),
    b VARCHAR(10));

-- 构建存储过程
drop procedure if exists insert_many_rows;

delimiter $$
create procedure insert_many_rows(in loops int)
modifies sql data
begin
declare v1 int;
set v1=loops;
while v1>0 do
insert into test_table(a,b) values('abd','efg');
set v1=v1-1;
end while;
end;
$$
delimiter ;

-- 调用
call insert_many_rows(100);
select * from test_table;
```
例如，构建一个存储过程，实现把某个类别的产品数量写入到1个变量中
``` mysql
delimiter $$
create procedure sort_count_proc(in v_sort_id varchar(5), out v_product_count integer)
reads sql data
begin
select count(*) into v_product_count
from product
where sort_id=v_sort_id;
end;
$$
delimiter ;

-- 调用
set @v_sort_id='11';
call sort_count_proc(@v_sort_id, @v_product_count);
select @v_product_count;
```

## 查看存储过程
创建完存储过程后，可以使用MySQL专门提供的语句查看存储过程
``` mysql
-- 查看存储过程的创建语句
SHOW CREATE PROCEDURE <proc_name>

-- 根据指定的模式查看所有符合要求的存储过程
SHOW PROCEDURE STATUS [LIKE 匹配模式];

-- 直接在information_schema.routines中查询
SELECT * 
FROM information_schema.routines; 
```
## 修改与删除存储过程
在MySQL中可以使用ALTER语句修改存储过程的特性，语句中的特性指的是存储过程中需要修改的部分，注意，ALTER PROCEDURE不能修改存储过程的**参数或程序体**。
``` mysql
ALTER PROCEDURE <proc_name> [properties];
```
properties选项有以下：
- comment
- language sql
- contain sql
- no sql
- reads sql data
- modifies sql data
- sql security definer
- sql security invoker

例如，修改sort_count_proc定义
``` mysql
alter procedure sort_count_proc
comment '统计某一个类别下的产品数量';
```

## 存储过程的异常和错误处理
在存储过程执行过程中，可对某些特定的错误代码、警告或异常进行定义，然后针对这些错误添加处理程序进行进一步的处理。
- 自定义错误名称
``` mysql
DECLARE 异常名称 CONDITION FOR [错误类型];
```
在上述语法中，错误类型由两种可选值，分别为mysql_error_code和SQLSTATE[VALUE] sqlstate_value。
前者是数值类型表示的错误代码，如1148，是MySQL中特有的错误代码；后者是5个字符长度的错误代码，如 SQLSTATE '42000'，取自ANSI SQL和ODBC。
例如，为错误状态定义名称
``` mysql
declare command_not_allowed condition for sqlstate '42000';
declare command_not allowed condition for 1148;
```

- 错误的处理程序
``` mysql
DECLARE 错误处理方式 HANDLER FOR 错误类型 [, 错误类型] ... 程序语句块；
```
错误类型包括CONTINUE（遇到错误不处理，继续执行），另一种是EXIT（遇到错误时马上退出）；程序语句段表示遇到定义的错误时，需要执行的存储过程代码块。
FOR后的错误类型可选值有以下几种：
- MYSQL_ERROR_CODE
- SQLSTATE
- SQLWARING表示所有以01开头的SQLSTATE代码
- NOT FOUND表示所有以02开头的SQLSTATE代码
- SQLEXCEPTION表示所有以01或02开头外的所有SQLSTATE代码

例如，
``` mysql
-- SQLSTATE '23000'或者1062表示插入行时，表中已包含重复键，因此不能插入。
declare continue handler for sqlstate '23000' set @is_success=0; -- 如果遇到23000错误，则执行set @is_success=0，并继续之后的语句
```



# 游标cursor

在存储过程或自定义函数中的查询可能返回多条记录，可以使用游标来**逐行读取**查询结果分别处理。
游标的使用包括声明游标、打开游标、使用游标和关闭游标。游标必须在**处理程序之前**声明，在**变量和条件之后**声明。游标用于标识数据的读取位置，可以和python中元组的下标对照理解。游标只能在**存储过程或函数**中使用。
游标有以下特性：
- 只读的，即不能更新游标指向的结果集
- 不滚动的，即不能直接跳过一些行

## 基本语法
- 声明游标
使用declare语句声明游标后，此时与游标对应的select语句并没有执行，mysql服务器内存中并不存在与select语句对应的结果集。
``` mysql
declare 游标名 cursor for select 语句;
```
- 打开游标
此时对应的select语句被执行，mysql服务器内存中存在与select语句对应的结果集，此时结果集存储在临时表中。
``` mysql
open 游标名;
```
- 从游标中提出数据
每提取一条记录，游标移到下一条记录的开头。当取出最后一条记录后，如果再次执行fetch语句，则产生"ERROR 1329(02000):No data to fetch"。遇到该异常，终止读取游标程序。
``` mysql
fetch 游标名 into 变量名1, 变量名2, ...;
```
- 关闭游标
释放游标打开的数据集，以节省mysql服务器的内存空间。如果没有被明确关闭，则它将再被打开的begin-end语句块的末尾关闭。
``` mysql
close 游标名
```
例如，定义存储过程，通过游标逐行更新某一类产品的所有产品的价格：如果大于1000，则上涨5%；否则，上涨10%。
``` mysql
DROP PROCEDURE IF EXISTS update_price_proc;
delimiter $$
CREATE PROCEDURE update_price_proc (IN v_sort_name VARCHAR(20))
MODIFIES SQL DATA
BEGIN
    -- 定义变量
    DECLARE v_product_id INT;
    DECLARE v_price DECIMAL(8, 2);
    DECLARE state CHAR(20); # 容易忘记定义处理报错的变量
    -- 定义游标
    DECLARE price_cur CURSOR FOR 
        SELECT product_id, price 
        FROM product natural JOIN sort 
        WHERE sort_name = v_sort_name;
  -- 定义异常处理
    DECLARE CONTINUE HANDLER FOR 1329 SET state = 'Error';
    
    OPEN price_cur; -- 打开游标
    REPEAT
        FETCH price_cur INTO v_product_id, v_price;  -- 移动游标，获取数据
        IF (v_price > 1000) THEN 
           SET v_price = v_price * 1.05;
        ELSE 
           SET v_price = v_price * 1.1;
        END IF;

        UPDATE product 
        SET price = v_price 
        WHERE product_id = v_product_id;
        UNTIL state = 'Error'  -- 如果没发生异常，则state为null；如果发生1329异常，state的值为error，此时终止repeat
    END REPEAT;
    
    CLOSE price_cur;  -- 关闭游标
END;
$$
delimiter ;

-- 调用
SELECT product_id, price 
FROM product natural JOIN sort 
WHERE sort_name = '办公机器设备'; -- 改变之前

CALL update_price_proc('办公机器设备');
SELECT * FROM sort WHERE sort_name='办公机器设备'; -- 改变之后
```



# 触发器 trigger

触发器的行为由数据操纵行为（例如插入、更新和删除）自动触发，因此一旦定义好，即可实现自动管理数据表。一些数据库的完整约束（如主键约束、外键约束和用户自定义约束等）可以基于触发器实现。
触发器可用于跟踪用户对数据库的操作，审计用户操作数据库的语句，将用户的数据操纵写入预定的审计表。触发器可以同步实时地复制表中的数据。触发器可以自动计算数据值，并根据数据值进行特定的处理。
需要注意的是，在INNODB表上的触发器中的语句和触发语句是在**同一个事务**中完成的，所以它们执行的操作是原子的，**触发语句和触发器操作会同时失败或成功**。
对于具有相同触发器动作时间(timing)和事件(event)的给定表，不能有两个触发器。例如，对于同一个表，不能同时有两个before update触发器，但可以有1个before update触发器和1个before insert触发器，或1个before update触发器和1个after update触发器。
MySQL没有提供ALTER TRIGGER语句。如果需要修改，则应先DROP TRIGGER，然后重新定义CREATE TRIGGER。

## 创建触发器
``` mysql
CREATE TRIGGER 触发器名 触发时机 触发事件 ON 表名 FOR EACH ROW
BEGIN
    触发程序
END;
```
- 触发时间: before / after，在事件发生前或后做触发程序
- 触发事件: insert / update / delete，表上的触发事件
  - insert: 将新行插入表时激活触发器，可以通过insert, load data和replace触发
  - update: 更新某一行时激活触发器，可以通过update或replace触发
  - delete:从表中删除某一行时激活触发器，可以通过delete或replace触发
- for each row: 行级触发器(mysql目前仅支持行级触发器，不支持语句级别的触发器, 如create table)
- 触发程序中的select语句不能产生结果集
- 触发程序中可以使用old和new关键字区别更新前后的行值
- old是只读的，可以引用，但不能更改。在before触发程序中，可使用"set new.col_name = value"更改new值。但在after触发程序中，不能使用"set new.col_name = value".

> 注意：
> - 触发器不能调用将数据返回客户端的存储过程，也不能使用采用CALL语句的动态SQL
> - 触发器不能使用以显式或隐式方式开始或接受事务的语句，如start stransaction，commit或rollback。
> - 使用old和new关键字可访问受触发器影响的列
>   - 在insert触发器中，仅能使用new.col_name
>   - 在delete触发器中，仅能使用old.col_name
>   - 在update触发器中，可使用old.col_name来引用更新前的某一行的列，new.col_name来引用更新后的某一行的列

例如，定义触发器，实现对插入或者更新操作的以下约束：不允许instructor的薪水值高于150000
> 分析：对于任意的数据操作，不允许更新后的薪水高于15000。
> - 插入一条或多条新记录，其中某行的薪水值高于15000
> - 修改一条或多条记录，其中修改后某行的薪水值高于15000

``` mysql
-- update
delimiter $$
create trigger instru_update_before_trigger before update on instructor for each row
begin
    if (new.salary > 150000) then
        insert into mytable values(0); -- 因为mytable未经定义，触发异常，更新操作失败。
    end if;
end;
$$
delimiter ;

-- insert
delimiter $$
create trigger instru_insert_before_trigger before insert on instructor for each row
begin
    if (new.salary > 150000) then
        insert into mytable values(0); 
    end if;
end;
$$
delimiter ;
```
例如，利用触发器实现sort表和subsort表之间的外键约束：subsort表的sort_id参照sort表的sort_id。
> 分析：需要分别定义从表和主表的更新和删除行为（before）
> - 主表：
>   - 删除一行时，检查从表中是否存在参照值
>   - 更新一行时，检查从表中是否存在参照行值，可进一步定义从表的参照值是否也对应更新（cascade）
> - 从表：
>   - 插入一行时，检查主表是否存在被参照值，如果不存在，则插入失败。
>   - 更新一行时，检查主表是否存在被参照值，如果不存在，则更新失败。

``` mysql
-- sort表上的更新: 更新subsort表对应的sort_id
DROP TRIGGER IF EXISTS sort_update_after_trigger;

DELIMITER $$
CREATE TRIGGER sort_update_after_trigger AFTER UPDATE ON sort FOR EACH ROW -- 此处设置为after update是为了不和subsort上的before update trigger会冲突
BEGIN
    UPDATE subsort
    SET sort_id = new.sort_id
    WHERE sort_id = old.sort_id;
END;
$$
DELIMITER ;

-- sort表上的删除: 检查subsort表中有没有对应的sort_id记录，有则删除 on delete cascade
DROP TRIGGER IF EXISTS sort_delete_before_trigger;

DELIMITER $$
CREATE TRIGGER sort_delete_before_trigger BEFORE DELETE ON sort FOR EACH ROW
BEGIN
    DELETE FROM subsort
    WHERE sort_id = old.sort_id;
END;
$$
DELIMITER ;

-- subsort表上的插入: 检查sort表中是否存在需插入的sort_id，若不存在，引发一个异常
DROP TRIGGER IF EXISTS subsort_insert_before_trigger;

DELIMITER $$
CREATE TRIGGER subsort_insert_before_trigger BEFORE INSERT ON subsort FOR EACH ROW
BEGIN
    SELECT COUNT(*) INTO @row_count 
    FROM sort 
    WHERE sort_id=new.sort_id;
    IF (@row_count = 0) THEN
        INSERT INTO mytable VALUES (0);
    END IF;
END;
$$
DELIMITER ;

-- subsort表上的更新: 检查subsort表更新后的sort_id值，若在sort表中不存在，引发一个异常
DROP TRIGGER IF EXISTS subsort_update_before_trigger;

DELIMITER $$
CREATE TRIGGER subsort_update_before_trigger BEFORE UPDATE ON subsort FOR EACH ROW
BEGIN
    SELECT COUNT(*) INTO @row_count 
    FROM sort 
    WHERE sort_id=new.sort_id;
    IF (@row_count = 0) THEN
        INSERT INTO mytable VALUES (0);
    END IF;
END;
$$
DELIMITER ;
```

## 查看触发器
``` mysql
-- 查看所有的触发器
show triggers;

-- 查看instructor表中的所有触发器
SELECT * 
FROM information_schema.triggers 
WHERE trigger_name = 'instructor';
-- 或者
SHOW TRIGGERS FROM instructor;

-- 查看指定触发器
HOW CREATE TRIGGER sort_update_after_trigger;
```
## 删除触发器
``` mysql
DROP TRIGGER 触发器名;
```



# Exercise

## 1
- 定义存储过程product_count_proc，输入参数v_sort_id，输出参数v_sort_count，语句块中查询给定类别为v_sort_id的产品数量，保存至v_sort_count。
``` mysql
drop procedure if exists product_count_proc;

delimiter $$
create procedure product_count_proc (in v_sort_id char(10),
out v_sort_count int)
reads sql data 
begin 
select count(*) into v_sort_count
from product
where sort_id=v_sort_id;
end;
$$
delimiter ;

call product_count_proc('11', @v_sort_count);
select @v_sort_count;
```
- 定义存储过程delete_expired_records_proc，无参数，语句块实现对operate_log30天前插入的记录的删除。
> date_add()：向日期添加指定的时间间隔
``` mysql
-- 前提条件
CREATE TABLE operate_log (id int primary key auto_increment,
                         user_id varchar(50) not null,
                         content varchar(255) not null default '',
                         operate_time timestamp default current_timestamp());

drop procedure if exists delete_expired_records_proc;

delimiter $$
create procedure delete_expired_records_proc()
modifies sql data
begin 
delete from operate_log
where date_add(operate_time, interval 30 day) < current_timestamp() ; 
end;
$$
delimiter ;

-- 调用
call delete_expired_records_proc();
```
- 定义存储过程update_remark_proc，通过定义游标，逐行更新orders表中的remark：如果quantity<10，更新remark的值为'小批量订单'；如果quantity在10和50之间，更新remark的值为'中批量订单'；如果quantity>50，更新remark的值为'大批量订单'。
``` mysql
drop procedure if exists update_remark_proc;

delimiter $$
create procedure update_remark_proc()
modifies sql data
begin 
declare v_remark varchar(20);
declare v_order_id int;
declare v_quantity int;
declare state char(20);
declare quantity_cur cursor for
select order_id, quantity from orders;

declare continue handler for 1329 set state='Error';

open quantity_cur;
repeat 
fetch quantity_cur into v_order_id, v_quantity;
if (v_quantity<10 and v_quantity >0) then
set v_remark='小批量订单';
elseif v_quantity<50 then
set v_remark='中批量订单';
else set v_remark='大批量订单';
end if;

update orders set remark=v_remark where order_id=v_order_id;
until state='Error'
end repeat;
close quantity_cur;
end;
$$
delimiter ;

select quantity, remark from orders limit 10;
call update_remark_proc();
select quantity, remark from orders limit 10;
```
## 2
- 定义触发器move_product_records_trigger，实现以下功能：删除product表中的记录后，将被删除的记录插入到product_his中，其中product_his与product有完全相同的属性，且有insert_time记录插入时间。
``` mysql
-- 建表product_his
CREATE TABLE product_his SELECT * FROM product WHERE 1=0; # 只保留product的表框架
ALTER TABLE product_his
ADD insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP();

drop trigger if exists move_product_records_trigger;

delimiter $$
create trigger move_product_records_trigger after delete on product for each row
begin
INSERT INTO product_his (product_id, product_name, product_code, product_place, price,
product_date, unit, detail, subsort_id, sort_id)
 VALUES (old.product_id, old.product_name, old.product_code, old.product_place,
old.price, old.product_date, old.unit, old.detail, old.subsort_id, old.sort_id);
end;
$$
delimiter ;

-- 调用
delete from product;
select * from product_his;
```