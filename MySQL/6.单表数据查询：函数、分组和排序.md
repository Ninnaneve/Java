# 聚合函数
- MAX()取列中的最大值
- MIN()取列中的最小值
- AVG()计算列的平均值
- COUNT()统计集合中元素的个数
- DISTINCT 字段剔除重复值

例如，使用count(distinct())统计product不重复值的个数
> 注意distinct所在的未知，是包含count还是被count包含

``` mysql
select count(distinct(sort_id)) from product;
```



# ORDER BY子句: 对查询结果排序

``` mysql
SELECT 字段名1,字段名2,……
FROM 表名
ORDER BY 字段名1 [ASC | DESC]，字段名2 [ASC | DESC]……
```
查询结果首先按字段1排序，如果字段1中有部分重复值，则按字段2进行排序，以此类推。

> 注意: 在按照指定字段进行升序排列时，如果某条记录的字段值为null，则这条记录会在第一条显示，null小于任何值。

例如， 查询product表中的product_id, product_name, product_place, price，返回结果先按product_place降序排列，然后按price升序排序
``` mysql
select product_id, product_name, product_place, price
from product
order by product_place DESC, price ASC;
```
- 字符串排序
将字符串转换为数值
例如，查询product表中的product_id, product_name, product_place, price，返回结果按product_id降序排列
> CAST(value AS type)或CONVERT(value, type)可对数据类型进行转换，type可以为：
> - CHAR[(N)] 字符型 
> - DATE  日期型
> - DATETIME  日期和时间型
> - TIME  时间型
> - FLOAT 单精度浮点
> - DOUBLE双精度浮点型
> - DECIMAL  float型
> - SIGNED 有符号 int类型
> - UNSIGNED 无符号int类型

``` mysql
select product_id, product_name, product_place, price
from product
order by cast(product_id as unsigned) desc;
```



# GROUP BY子句: 对查询结果统计分组

``` mysql
SELECT 字段名1,字段名2,……
FROM 表名
WHERE 条件表达式
GROUP BY 字段名1，字段名2，……
HAVING 条件表达式
ORDER BY 排序字段;
```
例如，按Product_Place分组，显示理光牌墨粉的产地，对应的记录数和平均价格
``` mysql
select product_place, count(*), avg(price)
from product
where product_name like '%理光%墨粉%'
group by product_place;
```
> 注意：为使查询具有现实意义，select后的字段应为**聚合函数**或**group by中出现的字段**。

- HAVING可以对结果集进行第二次过滤，即WHERE子句确定用于分组的数据集，HAVING确定分组之后的哪些数据行可以保留下来。

例如，根据product表计算不同产地的商品单价最大值，将单价最大值大于100元的产品的产地及单价最大值按Product_ID降序排列
``` mysql
select product_place, max(price)
from product
group by product_place
having max(price)>100
order by product_id desc;
```
> 注意：
筛选顺序：FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT

- 如果sql_mode中包含**only_full_group_by**设置，则在分组group by查询语句中，select子句后可跟分组字段、聚合函数、以及函数依赖于分组字段的字段（即该字段的值由分组字段值唯一决定）。如果需要select子句后跟非函数依赖于分组字段的字段，则可使用any_value(字段)的形式随机取多值中的一个值。
> 不是很懂

``` mysql
select @@session.sql_mode; --查看当前session的sql_mode
select sort_id, subsort_name, count(*)
from subsort
group by sort_id; -- 在only_full_group_by配置下不能运行

select sort_id, any_value(subsort_name), count(*)
from subsort
group by sort_id; -- 可运行
```
- group_concat()函数：将某一分组中的某一字段对应的所有字符串连接起来，即返回***分组中对应字段的所有值**
``` mysql
GROUP_CONCAT(col1 [ORDER BY col2 [DESC|ASC]] [SEPARATOR ''])
```
例如，查询各子类对应的product_name，用逗号连接起来
``` mysql
select subsort_id, group_concat(product_name order by length(product_name) ASC seperator ',') as name
from product
group by subsort_id;
```


# 系统函数

## 数学函数
``` mysql
select abs(-1);
select sqrt(4);
select mod(10,3); # 取余数，结果为1
select ceiling(9.3),floor(9.3);
select round(9.32,1); # 保留小数，且进行四舍五入
selecr truncate(9.321,2); # 截取相应位数，不进行四舍五入；若为负数，会把整数部分清零
select sign(-8.2),sign(0),sign(6); # 返回数字对应正负符号，本例返回-1，0，1

select pi(),sin(pi());cos(pi());tan(0);
```
## 字符串函数
``` mysql
select length('agcdef123');
select cancat('背景','--','音乐');
select length(trim(' aabdfe ');
select length(ltrim(' aabdfe ');
select length(rtrim(' aabdfe ');
select replace('背景音乐','背景','北京');
select substring('abcdef123',1,3); # 截取相应字符，首尾皆为闭区间
select reverse('abcdef123'); # 反转字符串
select locate('c','abcdef123'); # 查找索引
```
## 日期和时间函数
``` mysql
select now(); # 返回当前日期和时间
select curdate(); # 返回当前日期
select current_date(); # 返回当前日期
select curtime(); # 返回当前时间
select current_time(); # 返回当前时间
select sysdate(); # 返回系统日期和时间
select current_timestamp(); # 返回当前日期时间时间戳
select time_to_sec(curtime()); # 将时间转化为秒
select adddata('2012-12-21','7'); # 日期加运算
select subdata('2012/12/21','7'); # 日期减运算
-- 日期格式化函数
select date_format(now(),'%m-%d-%y'); -- m 月份；d 日期；y 2位年份
select date_format(now(),'%m-%d-%Y'); -- Y 4位年份
select date_format(now(),'%b %d %Y %h:%i %p'); -- b 月份缩写；d 日期；h 小时；i 分钟；p pm
select date_format(now(),'%d %b %y'); -- 
select date_format(now(),'%d %b %Y %T:%f'); -- T 时：分：秒；f 精确刻度
```
## 条件判断
``` mysql
select if(5>6,'True','False') -- 如果第1个参数为真，则取第2个参数，否则去取第3个参数值
select ifull(null,'空值'), ifnull(1,'空值'); -- 若第1个参数为空，取第2个参数的值
```
例如，查询product表中的product_id, product_name，sort_id ，subSort_id和product_date字段值，， 把sort_id 和subSort_id 用“-”连接起来，如果product_date字段的月份大于6则返回下半年，否则返回上半年。
``` mysql
select product_id, product_name, concat(sort_id,'-',subsort_id) as id,
if(month(product_date)>6,'下半年','上半年') as 半年
from product;
```

- 应用：让空值排末尾
``` mysql
select * from product
order by indull(price,-100);
select * from product
order by if(product_id is null,1,0), cast(product_id as unsigned);
```



# 为表和字段取别名

- 为表起别名
``` mysql
表名 [AS] 别名;
```
- 多表连接时，简化表名
例如，
``` mysql
select a.product_id, a.product_name, b.sort_name
from product a, sort b
where a.sort_id=b.sort_id;
```



# Exercise

在product表中完成以下查询
- (1)查找各品牌复印机的品牌名（命名为品牌）和最高零售价（命名为最高价）
> 假定商品名的前两个字符为品牌
一定要看清题意，这里是复印机的！
```mysql
select substring(product_name, 1,2) as 品牌, max(price) as 最高价
from product
where product_name like '%复印机%'
group by substring(product_name, 1,2);
```
- (2) 查找Product_Place和该产地的产品数（命名为产品数量），显示产品数在100种以上的产地和产品数量。
```mysql
select product_place, count(*) as 产品数量
from product
group by product_place
having count(*)>100;
```
- (3) 根据product表计算不同SubSort_ID的商品单价平均值（命名为Avg_Price），列出前10条记录。
```mysql
select subsort_id, avg(price) as Avg_Price
from product
group by subsort_id
limit 10;
```
- (4) 查询product表中的Product_ID, Product_Name和Product_Date字段值，如果Product_Date字段的月份大于6则返回下半年，否则返回上半年，并把if条件表达式命名为半年。
```mysql
select product_id, product_name, product_date,  if(month(product_date)>6,'上半年','下半年') as 半年
from product;
```
- (5) 查找Product_ID, Product_Name,Product_Date，并标记Product_Date对应的季度，把计算季度的表达式命名为季度。
```mysql
select product_id, product_name, product_date,  ceiling(month(product_date)/3) as 季度
from product;
```
- (6) 查找按产地和生产月份分组的零售价平均值，显示Product_Place,生产月份和零售价均值，并将生产月份命名为月份，零售价均值命名为"均价"。
```mysql
select product_place, month(product)date as 月份, avg(price) as 均价
from product
group by product_place, month(product);
```

