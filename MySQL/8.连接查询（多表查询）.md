# 交叉连接
交叉连接相当于关系的笛卡尔积。
如表A与表B进行交叉连接:
[![Ojq6Ts.jpg](https://s1.ax1x.com/2022/05/21/Ojq6Ts.jpg)](https://imgtu.com/i/Ojq6Ts)
``` mysql
SELECT *
FROM 表1 [CROSS | INNER] JOIN 表2;

-- 或者
SELECT *
FROM 表1, 表2;
```
> 一些商业关系型数据库的表并不等于理论上的关系，例如MySQL的表中若未设置主键约束，则可以存在重复行或存在空行，而这对于关系数据库理论中的关系而言是不允许的。
在实际应用中，一般不会使用交叉连接。原因在于交叉连接将产生大量的中间数据，占用大量内存。一般情况下，建议将交叉连接与选择条件一起构成**内连接或者自然连接**，以减少中间过程产生的数据量。



# 内连接

又称等值连接，为双目运算，定义了两表根据对应列的相等关系进行连接操作。
如表A与表B进行根据列c进行等值内连接:
[![OjLNB4.jpg](https://s1.ax1x.com/2022/05/21/OjLNB4.jpg)](https://imgtu.com/i/OjLNB4)
``` mysql
SELECT 查询字段
FROM 表1 [INNER | CROSS] JOIN 表2 ON 表1.字段1 = 表2.字段2;
-- 等价于
SELECT 查询字段
FROM 表1 [CROSS | INNER] JOIN 表2 
WHERE 表1.字段1 = 表2.字段2;
```
> 注意：字段1可以和字段2相同



# 外连接

外连接操作可以视为在内连接的结果基础上，加上左表(left join)或右表(right join)的未包含在内连接结果中的行。
> 注意: MySQL尚未支持全外连接操作。可以利用左外连接和右外连接的并集来替代。

``` mysql
SELECT 所查字段 
FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.字段 = 表2.字段;
```
以表A与表B为例：
[![OjOCKU.jpg](https://s1.ax1x.com/2022/05/21/OjOCKU.jpg)](https://imgtu.com/i/OjOCKU)

## 左外连接
[![OjOib4.jpg](https://s1.ax1x.com/2022/05/21/OjOib4.jpg)](https://imgtu.com/i/OjOib4)
``` mysql
select *
from a left join b 
where a.c=b.c;
```

## 右外连接
[![OjOkVJ.jpg](https://s1.ax1x.com/2022/05/21/OjOkVJ.jpg)](https://imgtu.com/i/OjOkVJ)
``` mysql
select *
from a right join b
where a.c=b.c;
```

## 全外连接
[![OjOAa9.jpg](https://s1.ax1x.com/2022/05/21/OjOAa9.jpg)](https://imgtu.com/i/OjOAa9)
``` mysql
select * from a left join b on a.c=b.c
union
select * from a right join b on a.c=b.c;
-- 或者
select *
from a join b
where a.c=b.c or a.c is null or b.c is null;
```
> UNION, UNION ALL都可以实现查询结构的并操作，不同之处在于UNION严格执行了集合并的概念，即剔除重复行；UNION ALL不剔除重复行，保留两个表中的所有数据。



# 自然连接和多表连接

## 自然连接: 寻找两表中相同的字段进行等值连接，去除重复字段
``` mysql
SELECT 字段列表
FROM 表1 NATURAL JOIN 表2;
-- 等价于
SELECT 字段列表
FROM 表1 JOIN 表2 ON 表1.字段 = 表2.字段;
-- 等价于
SELECT 字段列表
FROM 表1 JOIN 表2 USING(连接字段);
```
以表A与表B为例：
[![OjOCKU.jpg](https://s1.ax1x.com/2022/05/21/OjOCKU.jpg)](https://imgtu.com/i/OjOCKU)
[![OjjOVe.jpg](https://s1.ax1x.com/2022/05/21/OjjOVe.jpg)](https://imgtu.com/i/OjjOVe)
``` mysql
select *
from a natural join b;
-- 等价于
select *
from a join b on a.c=b.c;
-- 等价于
select * 
from a join b using(c);
```

## 多表间的连接
多表间的连接按从左往右的次序进行连接，例如,A JOIN B JOIN C, 先运算A JOIN B，然后将其结果与C进行连接。
例如，多表内连接
``` mysql
select count(*)
from product join sort join subsort on product.sort_id=sort.sort_id and subsort.sort_id=sort.sort_id;
```



# 子查询

SELECT语句的结果也为一张表，因此可以将SELECT的查询结果作为条件表达式中IN操作符的集合，或者直接作为下一次查询的起点。
## IN关键字
例如，查询子类别名“闹钟”对应的根类别信息。
``` mysql
select *
from sort
where sort_id in (select sort_id from subsort where subsort_name='闹钟');
```

## EXISTS关键字
例如，如果存在子类别编号为3101，则查询类别表中所有的记录。
``` mysql
select *
from sort
where exists (select sort_id from subsort where subsort_id=3101);
```

## ANY关键字
ANY操作符用于判断标量a与集合A之间的比较，例如a > ANY(A)如果标量a大于A中的某一个元素，则返回1；否则返回0。
> 等价于 a > MIN(A)

例如，查询满足以下条件的产地名称：对应单价大于产地为'大连'的任一产品价格。
``` mysql
select *
from product
where price > any(select price from product where product_place='大连');
```

## ALL关键字
ALL操作符用于判断标量a与集合A之间的比较，例如a > ALL(A)如果标量a大于A中的所有元素，则返回1；否则返回0。
> 等价于a > MAX(A)

例如，查询满足以下条件的产地名称：对应单价大于产地为'大连'的所有产品单价的产地。
> 注意要避免重复值

``` mysql
select distince product_place
from product
where price>all(select price from product where product_place='大连');
```



# P.S. 如何在MySQL中实现两表的交和差操作？

- 表T_A由product表中sort_id=11的product_id, product_name, price的行构成
- 表T_B由product表中price大于1000的product_id, product_name, price的行构成
## 交
- 左外连接
``` mysql
select l.*
from t_a l left join t_b r on l.product_id=r.product_id and l.product_name=r.product_name and l.price=r.price
where r.product_id is not null and r.product_name is not null and r.price is not null;
```
- IN子查询
``` mysql
select product_id, product_name, price
from t_a
where (product_id, product_name, price) in (select product_id, product_name, price from t_b);
```
- EXISTS子查询
``` mysql
select product_id, product_name, price
from t_a as o
where exists(select product_id 
from t_b 
where product_id=o.product)id and product_name=o.product_name and price=o.price);
```

## 差
- 左外连接
``` mysql
select l.*
from t_a l left join t_b r on l.product_id=r.product_id and l.product_name=r.product_name and l.price=r.price
where r.product_id is null and r.product_name is null and r.price is null;
```
- IN子查询
``` mysql
select product_id, product_name, price
from t_a
where (product_id, product_name, price) not in (select product_id, product_name, price from t_b);
```
- EXISTS子查询
``` mysql
select product_id, product_name, price
from t_a as o
where not exists(select product_id 
from t_b
where product_id=o.product_id and product_name=o.product_name and price=o.price);
```



# Exercise

(1) 使用内连接，查询product表和orders表中的订单号、订单时间、商品名称和订单数量。
``` mysql
select o.order_id, o.order_time, p.product_name, o.quantity
from product p inner join orders o on p.product_id=o.product_id;
```
(2) 在product表和orders表之间使用左连接查询商品id、商品名称、订单号、订单时间和订单数量。
> left/right join 需要有on 条件

``` mysql
select p.product_id, p.product_name, p.order_id, o.order_time, o.quantity
from product p left join orders o on p.product_id=o.product_id;
```
(3) 在product表和orders表之间使用右连接查询商品id、商品名称、订单号、订单时间和订单数量。
``` mysql
select p.product_id, p.product_name, p.order_id, o.order_time, o.quantity
from product p right join orders o on p.product_id=o.product_id;
```
(4) 在member表和orders表之间使用内连接查询订单号、订单时间、商品名id、商品数量和客户真实姓名，并按订单时间降序排列。
``` mysql
select p.order_id, o.order_time, p.product_id, p.quantity, o.real_name
from member m inner join orders o on m.user_name = o.user_name
order by o.order_time DESC;
```
(5) 使用IN查询商品产地为“广东”的商品订单信息。
``` mysql
select *
from orders
where product_id in (select product_id from product where product_place='广东');
```
(6) 使用EXISTS查询是否存在产地为“上海” 的商品订单信息，如果存在，查询所有订单信息。
``` mysql
select *
from orders
where exists(select product_id from product where product_place='上海');
```
(7) 使用ANY查询商品价格大于任一sort_id为11的商品价格的类别编号和类别名称（使用product和sort，要求去重）。
``` mysql
select distinct s.sort_id, s.sort_name
from sort s natural join product p
where p.price > any(select price from product where sort_id = 11);
```
(8) 使用ALL查询订单信息，其中商品价格要大于所有产地为“珠海”的商品商品价格，并按product_id升序排列。（使用orders表和product表）
> 看清题意！

``` mysql
select o.*
from product p natural join orders o
where p.product_id > all(select product_id from product where product_place='珠海');
```
