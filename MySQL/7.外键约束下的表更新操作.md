# 查询数据
可以通过从表的外键和主表的主键之间的参照关系完成跨表查询。
> 两表之间也可以不存在外键约束。



# 主从表中的数据插入、更新和删除

如何判断主从表之间建立外键之后，两表中的数据操作insert, update, delete会受到影响？
**判断依据**：进行数据更新时，要不违反外键约束，即更新数据过程中要保证**从表所有外键值包含在主表内或者为null**

## 插入数据
往**主表**中插入数据**不会影响到原表中的参照关系**，因此所有主表中的插入操作并不会影响外键约束。
往**从表**中插入数据时**可能违背外键约束**，例如要插入的外键值并不存在于主表中。此时，有3种解决办法：
1. 在主表中插入从表即将参照的外键值，然后再插入从表的值
2. 先删除外键约束，然后导入数据后重新创建
> 注意：若表中数据不满足外键约束的限定，则外键约束创建不成功
3. 设置外键约束失效set foreign_key_checks=0，导入数据之后再让其生效set foreign_key_checks=1
> 此方法慎用
注意：设置set foreign_key_checks=1后只对**新导入的数据**进行外键约束检查，即设置之前导入的从表的外键列的值可存在未出现在主表的值

例如，在从表product中添加记录sort_id=99
``` mysql
-- 在从表中插入主表中没有的值99，提示1452错误，违反外键约束
insert into product(sort_id) values ('99');

-- 方法1
insert into sort(sort_id) values('99');
insert into product(sort_id) values ('99');

-- 方法2
delete from product drop foreign key fk_sortid1;
insert into product(sort_id) values ('99'); -- 成功
alter table product add constraint fk_sortid1 foreign key sort_id references sort(sort_id); -- 失败
insert into sort(sort_id) values ('99');
alter table product add constraint fk_sortid1 foreign key sort_id references sort(sort_id); -- 成功

-- 方法3
set foreign_key_checks=0;
insert into product(sort_id) values ('99');
set doreign_key_checks=1;
insert into sort(sort_id) values ('99'); -- 别忘了插入主表相应值
```

## 删除数据
**从表**中删除任意行并**不会影响参照关系**，因此所有从表的删除操作都不会违背外键约束。
**主表**中数据行的主键值若被从表中的某些行参照，则将违背主键约束，从而删除失败。此时，有两种办法:
1. 先删除从表中的所有相关的记录，再删除主表中的所有相关记录
2. 将从表中的所有相关的记录行中的外键值设为null
3. 重新设置外键的删除级联类型

以上过程可以在业务层完成，也可以通过在定义外键约束时的on delete选项在数据库逻辑层完成。
例如，删除主表sort中的sort_id值为14的数据行
``` mysql
-- 直接删除，提示1451错误, 因为product表中有sort_id参照sort中的sort_id
delete from sort where sort_id ='14';

-- 方法1
delete from product where sort_id='14';
delete from sort where sort_id='14';

-- 方法2
update product set sort_id='null'
where sort_id='14';
delete from sort where sort_id='14';

-- 方法3
alter table product drop foreign key fk_sortid1;
alter table product add consraint fk_sortid1 foreign key sort_id references sort(sort_id) on delete cascade;
delete from sort where sort_id=='14';
```

## 更新数据
更新操作可视为**删除**和**插入**操作的组合。
- 如果on update restrict或on update no action时，只允许更新**主表中未被从表参照的主键值**，允许**将从表中的外键值更新为主表中的另一主键值**；
- 如果on update cascade或on update set null，则允许更新**主表中的任意值**。

例如，将sort表中sort_id=33更新为sort_id=93.
``` mysql
update sort set sort_id=93 where sort_id=33;

-- 方法1：on update cascade
alter table product drop foreign key fk_sortid1;
alter table subsort drop foreign key fk_sortid2;

alter table product add constraint fk_sortid1 foreign key sort_id references sort(sort_id) on update cascade;
alter table subsort add constraint fk_sortid2 foreign key sort_id references sort(sort_id) on delete cascade;

update sort set sort_id=93 where sort_id=33;

-- 方法2：on update set null
alter table product drop foreign key fk_sortid1;
alter table subsort drop foreign key fk_sortid2;

alter table product add constraint fk_sortid1 foreign key sort_id references sort(sort_id) on update not null;
alter table subsort add constraint fk_sortid2 foreign key sort_id references sort(sort_id) on update not null;

uodate sort set sort_id=93 where sort_id=33;
```



# Exercise

在给定的purchase数据库中完成以下操作
- 向subsort表添加如下表的记录。
[![OjtY1H.jpg](https://s1.ax1x.com/2022/05/21/OjtY1H.jpg)](https://imgtu.com/i/OjtY1H)
``` mysql
insert into sort(sort_id) values ('97'), ('98'), ('99');
insert into subsort(subsort_id,sort_id) values ('9701','97'), ('9702','97'), ('9801','98'), ('9802','98'), ('9901','99'), ('9902','99');
```
- 按照删除数据的三种方式逐次删除在sort表中的sort_id为97、98、99的记录。
> 要看清题意啊。
``` mysql
-- 方法1
delete from subsort where sort_id='97';
delete from sort where sort_id='97';

-- 方法2
update subsort set sort_id = null where sort_id='98';
delete from sort where sort_id='98';

-- 方法3
alter table subsort drop foreign key fk_sortid2;
alter table subsort add constraint fk_sortid2 foreign key sort_id references sort(sort_id) on delete cascade;
delete from sort where sort_id='99';
```

