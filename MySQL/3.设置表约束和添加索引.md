# 表约束
从对象级别来看，表的约束分为**字段级别约束**和**表级别约束**。
常见的字段级别约束包括：
- 非空约束(NULL/NOT NULL)
- 唯一约束(UNIQUE)
- 主键约束(PRIMARY KEY)
- 默认值(DEFAULT)
- 外键约束(REFERENCES)

其中，主键约束应同时满足**非空约束**和**唯一性约束**。
## 主键PRIMARY KEY
使用方法
- 新建表创建
``` mysql
CREATE TABLE course (字段名1 数据类型,
                     字段名2 数据类型,
                     ．．．．．．
                     字段名n 数据类型,
                     primary key (字段名));
```
- 已有表创建
``` mysql
ALTER TABLE 表名 MODIFY 字段名 数据类型[(宽度)] PRIMARY KEY;
```

### 单字段主键
单字段主键即在1个字段上构建的主键约束。
``` mysql
字段 数据类型[(宽度)] PRIMARY KEY
-- 或者
PRIMARY KEY (字段)
```
### 多字段主键
即在2个或多个字段上构建的主键约束。
``` mysql
PRIMARY KEY (字段1, 字段2, ....)
```
## 非空NOT NULL
设置非空约束的字段必须有值。
使用方式同上，PRIMARY KEY改为NOT NULL。

## 唯一性UNIQUE
用于创建唯一性索引。设置唯一性约束的字段的值不重复，即任意两行的该字段值不相同。
使用方式同上，PRIMARY KEY改为UNIQUE。

## 默认值DEFAULT
如果没有该字段未设定值，则取默认值。
使用方式同上，PRIMARY KEY改为DEFAULT 默认值。

## 自增AUTO_INCREMENT
只能设置在已具有**主键或者唯一性约束**的字段上。
在插入行时，若未在设定AUTO_INCREMENT的属性列上设置值，则该属性列的值相对上一行对应属性值加上1。
使用方式同上，PRIMARY KEY改为AUTO_INCREMENT。

- 查看约束
``` mysql
DESC 表名;
```

## 外键约束FOREIGN KEY...REFERENCES
> 注意事项
建立外键的表必须是**InnoDB型的表**，不能是临时表。
定义外键名时，不能加引号。
被参照表必须先于参照表定义，且被参照字段必须为被参照表的主键。

使用方法
- 新建表创建
``` mysql
CREATE TABLE [数据库名.]表名 (
    字段1 类型[(长度)] 其它列级约束,
    ...
    CONSTRAINT [外键约束名] FOREIGN KEY (参照字段) REFERENCES 被参照表(被参照表主键)
    [ON DELETE {CASCADE | SET NULL | NO ACTION | RESTRICT}];
)
```
- 已有表创建
``` mysql
ALTER TABLE 表名 ADD CONSTRAINT [外键约束名] FOREIGN KEY(参照字段) REFERENCES 被参照表(被参照表主键)
[ON DELETE {CASCADE | SET NULL | NO ACTION | RESTRICT}];
```
[ON DELETE {CASCADE | SET NULL | NO ACTION | RESTRICT}]
1. CASCADE: 主表中删除或更新对应的记录时，同时自动地删除或更新从表中匹配的记录。
2. SET NULL: 主表中删除或更新被参照列记录时，同时将从表中的外键列设为空。
3. NO ACTION: 拒绝删除或者更新主表被参照列记录，从表也不进行任何操作。
4. RESTRICT: 拒绝删除或者更新主表被参照列记录。

- 查看外键约束（表的构建语句）
``` mysql
SHOW CREATE TABLE 表名;
```
- 删除外键约束
``` mysql
ALTER TABLE 表名 DROP FOREIGN KEY 约束名称;
```



# 创建索引

索引是一种特殊的数据库结构，其作用相当于一本书的目录，以在查询时快速地定位到目标记录行。
用户创建的索引指向数据库中具体数据所在位置。当用户通过索引查询数据库中的数据时，不需要遍历所有数据库中的所有数据。
所有MySQL列类型都可以被索引，索引有两种存储类型：B+树和Hash。其中B+树为INNODB和MYISAM存储引擎的默认索引存储类型。

MySQL的索引包括
- 普通索引index/key
- 唯一性索引unique index：限制该索引对应列的值唯一。主键是一种特殊唯一索引。
- 全文索引fulltext：只能创建在char,varchar和text类型的字段上。
- 空间索引spatial：目前只有MYISAM存储引擎支持空间索引，而且索引的字段不能为空。

创建方式
- 新建表创建
例如，在stu_info数据库中创建student表及相关索引。
``` mysql
CREATE TABLE student(stu_id int(10),
                      name varchar(20),
                      course varchar(50),
                      score float,
                      DESCription varchar(100),
                      INDEX index_id(stu_id),                  #创建普通索引
                      UNIQUE INDEX unique_id(stu_id ASC),      #创建唯一性索引
                      FULLTEXT INDEX fulltext_name(name),      #创建全文索引
                      INDEX single_course(course(10)),         #创建单列索引
                      INDEX multi(stu_id, name(20))            #创建多列索引
                      );
```
- 已有表创建
CREATE INDEX
> 将索引视为独立的数据库对象。

例如，在book1利用create index创建索引。
``` mysql
CREATE INDEX index_id ON book1(bookid);                         #创建普通索引
CREATE UNIQUE INDEX uniqueidx ON book1(bookid);                 #创建唯一性索引
CREATE INDEX singleidx ON book1(comment);                       #创建单列索引
CREATE INDEX mulitidx ON book1(bookname(20), authors(20));      #创建多列索引
CREATE FULLTEXT INDEX fulltextidx ON book1(info);               #创建全文索引
```
ALTER INDEX
例如，使用ALTER TABLE语句在已经存在表book2上创建索引。
``` mysql
ALTER TABLE book2 ADD INDEX index_id(bookid);                   #创建普通索引
ALTER TABLE book2 ADD UNIQUE INDEX uniqueidx(bookid);           #创建唯一性索引
ALTER TABLE book2 ADD INDEX singleidx(comment(50));             #创建单列索引
ALTER TABLE book2 ADD INDEX mulitidx(bookname(20),authors(20)); #创建多列索引
ALTER TABLE book2 ADD FULLTEXT INDEX fulltextidx(info);         #创建全文索引
```

- 查看在某个表上创建的索引
``` mysql
SHOW INDEX FROM 表名;
```
- 删除索引
``` mysql
ALTER TABLE 表名 DROP INDEX 索引名;
-- 或者
DROP INDEX 索引名 ON 表名;
```



# Exercise

## 1
- 创建数据表product的以下约束
[![OqdpE8.jpg](https://s1.ax1x.com/2022/05/19/OqdpE8.jpg)](https://imgtu.com/i/OqdpE8)
> 使用alter时，comment不要忘记加在结尾
``` mysql
create table product(
product_id char(10) primary key comment '商品编号',
product_name varchar(100) unique comment '商品名称',
product_code varchar(10) not null comment '商品编码',
price float default 0 comment '商品价格');
# 其余重复，省略

-- 使用改变版本
alter table product modify product_id char(10) primary key comment '商品编号';
alter table product modify product_name varchar(100) unique comment '商品名称';
alter table product modify product_code varchar(10) not null comment '商品编码';
alter table product modify price float default 0 comment '商品价格';
```
## 2
[![Oqwb6A.jpg](https://s1.ax1x.com/2022/05/19/Oqwb6A.jpg)](https://imgtu.com/i/Oqwb6A)
导入purchase.sql生成数据库purchase，对其中的数据表建立以下约束
- (1) 构建product表的主键为product_id, sort表的主键为sort_id, subsort表的主键为subsort_id
``` mysql
alter table product modify product_id char(10) primary key;
alter table sort modify sort_id char(2) primary key;
alter table subsort modify subsort_id char(5) primary key;
```
- (2) 构建product表与sort表之间的外键约束fk_sortid，外键为sort_id
> 是constraint而不是constraints，是references而不reference
``` mysql
alter table product add contraint fk_sortid1 foreign key (sort_id) references sort(sort_id);
```
- 构建subsort表与sort表之间的外键约束fk_sortid2，外键为subsort_id，并设置为on delete cascade。
> 若发现建立外键失败，需要先查询尚未建立起外键约束的两表（例如本题的product表和sort表）对应的列（sort_id）是否满足建立外键约束的条件。
如果查询中包含记录，则需要对这些数据进行处理，例如往主表中添加对应的记录，或者直接在从表中删除这些记录。
``` mysql
-- 查看product表中subsort_id列是否有subsort表中subsort_id列未包含的值
select distinct sort_id
from product
where sort_id not in (select sort_id from sort);
-- 若有查询结果，则进行以下操作，在从表中删除相应记录或在主表中添加相应记录
set sql_safe_uodate=0;
delete from product where sort_id='对应结果';
insert into sort(sort_id)
values('对应结果')；
-- 若无，则直接建立外键
alter table subsort add contraint FK_sortid2 foreign key (sort_id) references sort(sort_id) on delete cascade;
```
- (4) 构建product表与subsort表之间的外键约束fk_subsortid，外键为subsort_id 
``` mysql
alter table product add constraint fk_subsortid foreign key subsort_id references subsort(subsort_id);
```
- (5)删除product表中的Subsort_ID的外键约束。
``` mysql
alter table product drop foreign key fk_subsort_id;
```
## 3
创建数据表Product的相关索引。
- 创建Product_Code字段的唯一性索引
> index的起名方式可以参考
``` mysql
create unique index idx_pcode on product(product_code);
```
- 创建Detail字段的普通索引
``` mysql
create index uidx_detail on product(detail);
```
- 创建Product_Place字段的全文索引
``` mysql
create fulltext index fulidx_place on product(product_place);
```
