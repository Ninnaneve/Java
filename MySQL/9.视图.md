# 创建视图
视图是由一个或多个表（视图）导出来的**虚拟表**，其结构和数据都依赖于基本表。
它**不占用实际的存储空间**，只是在数据字典中存储它的定义信息。
通过视图不仅可查看基本表中的记录，也可查询、修改和删除基本表中的数据。
- 为什么需要使用视图？
    - 简化查询。例如基于一些多表或分组复杂查询构建视图。
    - 安全性。过滤掉一些敏感信息，如member表中的user_passw。
    - 逻辑数据独立性。

``` mysql
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)]
AS 
SELECT查询语句
[WITH [CASCADED | LOCAL | CHECK OPTION] ];
```
> CREATE：表示创建视图的关键字。
OR REPLACE：如果已经有相同名称的视图，则替换已有视图定义。
ALGORITHM：可选，表示创建视图选择的算法。
> - UNDEFINED：表示MySQL将自动选择所要使用的算法。一般偏向于merge。
> - MERGE：在涉及视图的SQL语句中，将视图定义取代查询语句的对应部分；在执行效率上比temptable更加高效。
> - TEMPTABLE: 在涉及视图的SQL语句中，将视图结果存入**临时表**，然后在临时表的基础上再执行语句；可以不在视图定义涉及的表上加锁，利于并发。
view_name：表示要创建的视图名称。
column_list：可选，表示属性清单。
AS：表示指定视图要执行的操作。
SELECT_statement：表示从某个表或视图中查出满足条件的记录，并导入视图中。
WITH CHECK OPTION：可选，表示创建视图时要保证在该视图的权限范围之内。
> - CASCADED：需要满足跟该视图有关的所有相关视图和表的条件，该参数为默认值。
> - LOCAL：可选。表示创建视图时，只要满足该视图本身定义的条件即可。

## 查看视图结构和定义
- 查看视图的结构
``` mysql
DESC[RIBE] <view_name>;
```
- 查看视图的DDL
``` mysql
SHOW CREATE TABLE | VIEW <view_name>;
```

## 使用表中所有的字段创建简单视图
例如，查询product表中类别编号为11的所有记录，创建视图view_product
``` mysql
create view view_product
as
select *
from product
where product_id=11;
```

## 指定表中的某些字段构建视图
例如，创建视图view_product2，包含product表中的product_id, product_name, product_place, subsort_id。
``` mysql
create view view_product2
as
select product_id, product_name, product_place, subsprt_id
from product;
```

## 为分组查询（GROUP BY）构建汇总视图
例如，创建视图sum_product，包含product中product_place和各产地对应的产品数
``` mysql
create view sum_product
as
select product_place, count(*) as 产品数
from product
group by product_place;
```

## 为多表查询建立视图
例如，创建视图view_sort_product，包含类别名称和对应的产品数量
``` mysql
create view view_sort_product
as
select s.sort_name, count(p.product_id) as 产品数量
from sort s natural join product p
group by s.sort_name;
```
## 视图字段的重命名
如果未对视图中的字段进行重命名，则默认使用查询语句中的字段名称。
若未对查询中的表达式重命名，则在对该字段进行查询时需加上反引号。
例如，创建视图sum_product，包含product中的product_place，各产地对应的产品数量，并命名为num_product
``` mysql
create view sum_product(product_place, num_product)
as 
select product_place, count(product_id)
from product
group by product_place;
-- 或者
create view sum_product
as 
select product_place, count(product_id) as num_product
from product
group by product_place;
```


# 查询视图

``` mysql
SELECT * | 视图字段列表
FROM 视图名称
WHERE 条件表达式;
```
> 等价于在AS后查询结构的基础上再进行筛选



# 修改或重新定义视图

## 利用CREATE OR REPLACE VIEW重新定义视图
例如，重新定义视图view_product，包含product_id, product_name, product_place, sort_id, subsort_id。
``` mysql
create or replace view_product3
as 
select product_id, product_name, product_place, sort_id, subsort_id
from product;
```
## 使用ALTER语句修改视图定义
> 注意：被修改的视图必须要存在

``` mysql
ALTER [ALGORITHM = {UNIDIFIED | MERGE | TEMPTABLE}]
VIEW view_name [(column_list)]
AS SELECT查询语句
[WITH [CASCADE | LOCAL] CHECK OPTION];
```
例如， 修改视图结构view_product, 包含product_id, product_name, product_place
``` mysql
alter view view_product
as 
select product_id, product_name, product_place
from product;
```



# 通过视图操作基本表的记录

> 注意，当视图包含以下结构时，则不能对视图执行插入、更新或删除操作不能执行：
（1）包含基本表中被定义为非空的列
（2）select语句后的字段列表中使用了数学表达式
（3）select语句后的字段列表中使用了聚合函数
（4）select语句使用了DISTINCT, TOP, GROUP BY, UNION, UNION ALL 或 HAVING子句
（5）algorithm=temptable的视图
（6）对基础表的某一列有多次引用

## 更新 UPDATE
例如，通过view_product把product_place为'国产'的产品记录的对应值更改'中国'
``` mysql
update view_product
set product_place='中国'
where product_place='国产';
```
## 插入 INSERT
例如，通过view_product插入一条product_id = '12345', product_name='3d打印机', product_place='上海'的记录
``` mysql
insert into view_product(product_id, product_name, product_place) values ('12345','3d打印机','上海');
```
## 删除 DELETE
例如，通过view_product删除product_name为'3d打印机'的记录
``` mysql
delete from view_product where product_name='3d打印机';
```



# 删除视图

``` mysql
DROP VIEW 视图名称;
```
> 不过一般倾向于写为drop view if exists 视图名称;



# Exercise

- (1) 创建view_member视图, 包含member表中的user_name, sex, email等字段，并用查看视图结构和定义。
``` mysql
create view view_member
as
select user_name, sex, email
from member;
```
- (2) 创建view_sort视图，包含sort表中的sort_name， 以及其对应的子类别的数量，并命名为num_subsort
> 注意不同表之间键的关系，本题是以sort_id相连的，sort中并没有subsort_id，因此需要通过自然连接进行查询。
``` mysql
create view view_sort
as 
select a.sort_id, a.sort_name, count(b.subsort_id) as num_subsort
from sort a natural join subsort b
group by a.sort_id;
```
- (3) 在view_sort视图查询类别名称中有'办公'两个字的所有记录
> 看清题意！
``` mysql
select *
from view_sort
where sort_name like '%办公%';
```
- (4) 利用CREATE OR REPLACE VIEW或者ALTER VIEW修改视图view_member，使其包含member表中的user_name, sex, email, address, phone等字段
``` mysql
create or replace view view_member
as
select user_name, sex, email, address, phone
from member;
```
- (5) 通过view_member更新user_name为'饿狼'的记录的true_name为'胡颖'
``` mysql
update view_member set true_name='胡颖' where user_name='饿狼';
```
- (6) 通过view_member插入一条记录，user_name为'风清扬', true_name为'张三丰', sex为'女'
``` mysql
insert into view_member(user_name, true_name, sex) values ('风清扬', '张三丰', '女');
```
- (7) 通过view_member删除user_name为'风清扬'的记录
``` mysql
delete from view_member where user_name = '风清扬';
```
- (8) 删除视图view_member
``` mysql
delete view if exists view_member;
```



# P.S.

## algorithm: merge | temptable
例如，对于view_product，有
``` mysql
CREATE OR REPLACE ALGORITHM=MERGE VIEW view_product
AS
SELECT * FROM product
WHERE sort_id = 11;
```
如果我们要在该视图上查询价格大于1000的产品，即
``` mysql
SELECT * FROM view_product WHERE price > 1000;
```
如果指定为merge算法，则对其查询会发生对应定义的替换。以上语句被替换为
``` mysql
SELECT * 
FROM product 
WHERE sort_id = 11 AND price > 1000;
```
如果指定为temptable算法，会先得到中间结果，再其基础上进行下一步的查询。则以上语句被转换为
``` mysql
SELECT *
FROM (SELECT * 
     FROM view_product WHERE sort_id=11) a
WHERE price > 1000;
```
由于临时表没有索引，所以效率通常较低。

## with check option: cascaded | local
WITH CHECK OPTION用于规范可更新视图的更新行为，以限定视图定义子句where表达式的作用范围。
它有两个选项，如果不定义，则默认为cascaded，即在执行视图插入或更新操作时，检查**该视图定义中的where以及该视图依赖的所有视图定义中的where条件**，如果插入的行不满足其中任意一个，则插入不成功。
如果设定为local选项，则只检查**当前视图定义中的where条件**。
- 加与不加with check option的对比
``` mysql
-- 不加with check option选项
create or replace view view_product
as
select * from product where sort_id = 11;

start transaction;
insert into view_product(product_id, sort_id)
values(9999,12); -- 执行成功，即使sort_id为12不满足view_product的定义

select * from product where product_id = 9999; -- 可以查看到相关记录
select * from view_product where product_id = 9999; -- 无结果，因为sort_id不为11
rooback; -- 回滚到start transaction开始前的数据库状态

-- 加with check option选项
create or replace view_product
as 
select * from product where sort_id=11
with check option; -- 默认为cascade选项

start transaction;
insert into view_product(product_id, sort_id) values (9999,12); -- 执行不成功
rollback;
```
- with local check option和with cascaded check option的对比
``` mysql
-- local
create or replace view view_product
as
select * from product where sort_id = 11;

create or replace view view_view_product
as
select * from view_product where price > 1000
with local check option;

start transaction;
insert into view_view_product(product_id, price, sort_id)
values (9999, 2000, 12); -- 执行成功, 虽然违背view_product的where条件sort_id = 11

insert into view_view_product(product_id, price, sort_id)
values (10000, 200, 11); -- 插入失败：lock check，不满足view_view_product的price < 1000

select * from product where product_id = 9999; -- 有结果
select * from view_product where product_id = 9999; -- 无结果
select * from view_view_product where product_id = 9999;  -- 无结果
rollback;

-- cascaded
create or replace view view_product
as
select * from product where sort_id = 11;

create or replace view view_view_product
as
select * from view_product where price > 1000
with cascaded check option;

start transaction;
insert into view_view_product(product_id, price, sort_id)
values (9999, 10000, 12); -- 执行失败，cascade选项级联检查view_product的条件
rollback;
```
