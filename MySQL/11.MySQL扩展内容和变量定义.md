#  衍生列（generated column）
在基础列的上，通过一定的运算转换而定义生成的列，即为衍生列。衍生列可用于实现概念模型设计的部分计算属性和复合属性，实现查询性能上的优化。

- 新建表创建
``` mysql
CREATE TABLE <t_name> (
    col <col_type>,
    g_col <col_type> GENERATED ALWAYS AS (<computation on col>) [stored | virtual] [NOT NULL] [PRIMARY KEY]
    );
```

- 已有表创建
``` mysql
alter table 表名 modify 字段名 字段类型 generated always as (<computation on col>) [stored | virtual] [NOT NULL] [PRIMARY KEY]
    );
```

有两种类型的衍生列：stored和virtual，默认为virtual
- stored意味着有物理空间直接存储生成列的值，可以在上面建立**聚集或二级索引**；
- virtual意味着在查询该字段时生成对应的列值，可以在上面建立**二级索引**，但不能建立聚集索引。

衍生列的构建可包含：
- 字面量
- 确定性内建函数和操作符
- 基本列
- 创建于其前的衍生列

衍生列的构建不可包含：
- 不确性内建函数，如current_date(), current_timestamp(),connection_id()等
- 用户自定义存储过程，系统、用户、局部变量等
- 子查询
- 在其后定义的生成列
- auto_increment

衍生列的适用场景：
- 简化和整合查询。复杂条件可通过衍生列表示，查询可直接指向该列，从而保证查询条件的一致性。
- 作为复杂条件或运算的物化存储，提前缓存，从而减少查询时间
- 模拟函数索引，如可在json列中的某些子属性创建衍生列，进而构建索引。（缺点在于，该属性数据需存储两次）
- 查询优化器可识别出使用了衍生列定义的查询，从而可利用创建在衍生列上的索引，即便该查询未直接使用该列。

衍生列的使用限制：
- 衍生列不能作为被参照列，即不能被其它表的列参照。
- 参照列上的外键约束on update选项不能设为cascade, set_null,set default；on delete选项不能设为set null,set default
- 触发器中不能用new.col_name和old.col_name指代衍生列

> 使用create table ... like可保留原表中的衍生列定义；使用create table ... select则不能，只能生成对应时刻数据对应的基础列。

例如，
``` mysql
-- 新建表创建
create table person(
id int primary key,
first_name varchar(20) not null,
last_name varchar(20) not null,
name varchar(50) generated always as (concat(first_name,' ',last_name)) stored,
index idx_name(name));

-- 已有表创建
alter table person modify name varchar(50) generated always as (concat(first_name, ' ', last_name)) virtual;

-- 查看效果
insert into person(id, first_name, last_name)
values (1,'Judy','Abbott');
select * from person;
```



# REPLACE: 插入或更新

插入数据时，如果目标表中已存在相同的主键或有unique约束的属性值，则以此作为条件**更新***剩余属性值；如果不存在，则执行**插入**操作。如果目标表中没有定义主键或者唯一性约束字段，则replace into 等价于 insert into。
- 方法1
其中，value: {expr | DEFAULT}；value_list: value [, value] ...
``` mysql
REPLACE INTO tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [(col_name [, col_name] ...)]
    {VALUES | VALUE} (value_list) [, (value_list)] ...
```
- 方法2
其中，assignment: col_name = value；assignment_list: assignment [, assignment] ...
``` mysql
REPLACE INTO tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    SET assignment_list
```
- 方法3
``` mysql
REPLACE INTO tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [(col_name [, col_name] ...)]
    SELECT ...
```
例如，
``` mysql
-- 定义表
CREATE TABLE p (p_id char(5) primary key,
               p_name varchar(50) unique,
               price decimal(7, 2) not null default 0);

-- 进行replace操作
replace into p
values(1,'a',1.2), (2,'b',5.0) --插入
replace into p(p_id, p_name, price)
values(1,'a',3); -- 更新p_id值为1时，p_name为'a'的行的price值为3
replace into p(p_id, p_name, price)
values (2,'b',4.0), (3,'f',3); -- 同时更新和插入

-- 小心以下更新
replace into p(p_id,p_name,price)
values(3,'b',6); -- -- 更新p_id值为3的行(3, 'f', 3) -> (3, 'e', 6)；更新p_name为'b'的行(2, 'b', 4.0) -> (3, 'b', 6), 然后去重.
```



# TEMPORARY TABLE临时表

如果需要保存一些查询的中间结果，可以使用临时表temporary table。用户在某一次会话（session）中创建的临时表只在该次会话可见，会话结束时临时表也将自动删除。
因此，两个不同的会话可以在同一个数据库中创建相同名称的临时表。注意，临时表的名称可以与正式表相同，此后数据操作涉及该表名时将优先选择**临时表**。
> 注意，临时表上不能创建索引。

例如，
``` mysql
-- 创建临时表
create temporary table temp_product(product_id int primary key,
product_name varchar(50),
price decimal(7,2));

create temporary table product 
as 
select * from product limit 10; -- 临时表可以和正式表名称相同

-- 查看临时表定义
show create table temp_product;

-- 删除临时表
drop temporary table temp_product;
```



# 变量定义与运算符

## MySQL编程中涉及的常量
- 字符串常量
MySQL推荐使用单引号表示字符串
例如，
``` mysql
select 'I\'m a \teacher' as col1, "you're a studen\t" as col2;
```
- 数值常量
``` mysql
select 123 as number;
```
- 日期时间常量
``` mysql
select now() as now;
select year(now()), month(now()), day(now()), hour(now()), minute(now()), seconde(now()) as today();
```
- 布尔值
``` mysql
select true, false;
```
- 二进制
``` mysql
select 0b111001, b'111001';

-- 进制转换
select conv('10',10,2) -- 10进制转化为2进制
select bin(8); -- 同上
```
- 十六进制
``` mysql
select x'41', x'4D7953514C';
select 0x41, 0x4d7953514c;

-- 进制转换
select conv('42',16); -- 10进制转化为16进制
select hex(42), hex(16); -- 同上
```
- null
``` mysql
select null, null>1; -- null与任何值进行比较的结果为null
```
## 用户自定义变量
### 用户会话变量
可以利用set或者select创建用户会话变量
- 方法1：set
``` mysql
SET  @user_variable1 = expression1 [, @user_variable2 = expression2, ...];
-- 或者(一般不用)
SET  @user_variable1 := expression1 [, @user_variable2 := expression2, ...];
```
例如，
``` mysql
set @user_name='张三';
select @user_name;

-- 同时定义多个变量
set @user_name=b'11', @age=18
select @user_name, @age;

-- 对变量进行更新
set @age=@age*3+1;
select @age;
```

- 方法2：select
``` mysql
select @user_variable1 := expression1 [, @user_variable2 := expression2, ...];
-- 或者
select experession1 into @user_variable1, experession2 into @user_variable2, ...;
```
> 注意和set定义变量的区别：用set定义变量时，直接使用=；用select定义变量时，使用':='

例如，
``` mysql
select @a:='b';
select @a;

-- =与:=比较
select @a='a'; -- 用户定义变量a与'a'进行等值比较的结果，如果a之前定义了，则返回1或0；如果a之前未被定义，则返回null
select @a;

-- into方式，定义多个变量
select '张三',19 into @user_name, @age;
select @user_name, @age;
```
### 使用用户会话变量保存SQL查询结果
例如，将product表中的记录数赋值给用户会话变量@product_count
``` mysql
-- 方法1: set @变量名 = select语句
set @product_count = (select count(*) from product);
seelct @product_count;

-- 方法2: select @变量名 := select语句
select @product_count:=(select count(*) from product);
select @product_count;

-- 方法3: select @变量名 := 聚合函数 from 表
select @product_count:=count(*) from product;
select @product_count;

-- 方法4：select 聚合函数 from 表 into @变量名
select count(*) from product into @product_count;
select @ product_count;
```
例如，通过定义用户变量查询product表中的特定行
``` mysql
set @product_code='1101001';
select * from product where product_code=@product_code;
```
例如，通过自定义变量查询sort_name为纸张的所有产品信息
``` mysql
select @v_sortid := (select sort_id from sort where sort_name='纸张');
select * from product where sort_id=@v_sortid;
```
例如，从product表中获取所有记录奇数行构成的集合。
> 低版本的MySQL没有行号函数，可通过定义用户会话变量来模拟实现。
Q：不理解是怎么循环起来的

``` mysql
select row_num, product_id, product_name, price
from (select @row_num:=@row_num+1 as row_num, product_id, product_name, price 
from product, (select @row_num:=0) as r
order by cast(product_id as signed)) as b_product
where row_num mod 2 = 0;
```
例如，应用用户会话变量生成组内排名：查询各sort_id下产品类别数量排名前5（可以重复排名）的subsort_id，返回sort_id, subsort_id, 产品数量, 类别内排名
> Q：不理解是怎么循环起来的

``` mysql
select sort_id, subsort_id, num_product, 排名 
from (select sort_id, subsort_id, num_product, if(sort_id=@last_sort_id, if (num_product=@last_num_product, @r, @r:=@r+1),@r:=1) as 排名, @last_sort_id:=sort_id,  @last_num_product:=num_product
from (select sort_id, subsort_id, count(*) as num_product
from product
group by subsort_id
order by sort_id, num_product desc) as x, (select @r:=0) as r) as a
where 排名<=5;
```
## 运算符
### 算术
``` mysql
-- 数值类型
set @num=15;
select @num+2, @num-2, @num*3, @num/3;
select @num%2; # 求余数
select @num+null, @num-null, @num*null, @num/null, @num%null; # 结果均为null
select @num/0, @num%0; # 结果均为null
select pow(3,3);

-- 日期类型
select '2012-12-21'+interval'50'day;
select '2012-12-21'-interval'50'day;
```
### 比较
``` mysql
-- 字符比较
select 'ab'='ab', ' ab'='ab', 'b'>'a'; # 结果为1, 0, 1

-- 字符与数值混合比较，比较时字符会自动转成数值
select '1'=1, '1'>0, 1>'0', '1'>'0'; # 结果全为1

-- 空值比较
select null=null, null<null, null is null, null is not null; # 结果为null, null, 1, 0
select null>1, null<1, null=1; # 结果均为null
select null!=null, null<>null; -- <>表示不等于，结果均为null
select isnull(null);

-- 中间值比较
select 'b' between 'a' and 'c'; # 结果为1
select 10 not between 'a' and 'c'; # 结果为1

-- 集合比较
select 1 in (1,2,'a');
select 1 not in (1,2,'a');

-- 字符比较
select 'stud' like 'stud', 'stud' like 'stu_', 'stud' like 'st%';
select 'student' regexp '^s', 'student' regexp '[a-z]';
```
### 逻辑
``` mysql
select 1 and 2, 2 and 0, 2 and true, 0 or true, not 2, not false;
select 1&&2, 2&&0, 2&&true, 0||true, !2, !false;
select null&&2, null||2, !null;

-- 运算优先级, 先运算and，后运算or
select 1 and 0 or 1;
select 0 or 0 and 1;
select not 1 or 0 and 1;
```


# prepared statement预处理语句

MySQL5.7提供了服务器端的预处理语句，有以下优点：
- 预先在服务器端一次定义好语句，产生优化好的执行计划，后面使用的时候只需传递相关参数即可，因此减少了网络传输负担
- 防止SQL注入攻击，预处理语句可传输非字符串变量。
``` mysql
-- 定义
PREPARE <statement_name> FROM '<SQL>'；

-- 执行
EXECUTE <statement_name> USING @v1, @v2,....；

-- 解绑
DEALLOCATE  PREPARE <statement_name>；
```
<SQL>中的变量用?替代，以下SQL可以定义在预处理语句的sql字符串中:
- ALTER TABLE 
- ALTER USER 
- INSERT
- SELECT
- UPDATE
- DELETE
- TRUNCATE
- SET
- RENAME TABLE
- {CREATE | RENAME | DROP} DATABASE
- {CREATE | DROP} TABLE
- {CREATE | RENAME | DROP} USER 
- {CREATE | DROP} VIEW
- SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
- ...
> 注意，prepare statement是用户会话级别定义的，即如果未解绑一个prepare statement，则在用户中断会话时将自动解绑

例如，定义预处理语句“选取价格大于某一值的所有记录”
``` mysql
prepare stmt_select from 'select product_id, product_place, price 
from product where price > ? 
order by price';
set @n=100;
execute stmt_select using @n;
deallocate prepare stmt_select;
```
例如，定义预处理语句“插入产品编号、名称和价格至产品表”
``` mysql
prepare stmt_insert from 'insert into product(product_id, product_name, price) values(?,?,?);'
set @pid=9999,@pname='矿泉水',@price=2;
execute stmt_insert using @pid, @pname, @price;
deallocate prepare stmt_insert;
```



# Exercise

- 将十进制数1239分别转换为二进制和十六进制数
> conv第一位一般为数值，字符也会自动转为i数值，两个函数可以并到一个select中写。
``` mysql
select conv(1239,10,2), conv(1239,10,16);
```
- 使用示例3中的4种方法，分别定义用户变量count_member1, count_member2, count_member3, count_member4, 保存member表中的记录数
``` mysql
-- 方法1
set @count_member1=(select count(*) from member);
select @count_member1;

-- 方法2
select @count_member2:=(select count(*) from member);
select @count_member2;

-- 方法3
select @count_member3:=count(*) from member;
select @count_member3;

-- 方法4
select count(*) from member into @count_member4;
select @count_member4;

```
- 定义表budget，包含项目编号, 项目名称, 交通费, 会议费, 打印费等基础属性，以及总预算virtual衍生属性，总预算为交通费, 会议费, 打印费之和。
> decimal(M,D)，M为数字最大数，D为小数位数，本题费用较为精确（需要保留两位数），因此用decimal更好
还有写完一定要在读一遍题目，避免忘记要定义的属性，如漏了virtual
``` mysql
create table budget(
project_id int,
project_name char(20),
trans_fee decimal(6,2),
meeting_fee decimal(6,2),
print_fee decimal(6,2), 
sum_fee decimal(7,2) generated always as (trans_fee+meeting_fee+print_fee) as sum_fee) virtual;
```
- 基于sort和subsort定义临时表temp_sort_num，用于存储根类别编号、名称和对应该类别的子类别数量。
``` mysql
create temporary table temp_sort_num 
as 
select sort_id, sort_name, count(subsort_id) as num_subsort
from sort natural join subsort
group by sort_id;
```

