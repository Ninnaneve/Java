编程语言的产生也始于**对机器的模仿**。

面向对象程序设计（Object-oriented Programming, OOP）便是这种以计算机作为表达媒体的大趋势中的组成部分。

## 1.1 抽象过程

所有编程语言都提供**抽象机制**。

人们所能够解决的问题的复杂性直接取决于**抽象的类型和质量。**

> 类型：“所抽象的是什么？”

汇编语言：对底层机器的轻微抽象。

“命令式”语言（如FORTRAN、BASIC、C等）：对汇编语言的抽象。这些语言在汇编语言基础上有了大幅的改进，但是它们所作的主要抽象仍要求在解决问题时要**基于计算机的结构，而不是基于所要解决的问题的结构**来考虑。

因此，程序员必须建立起**在机器模型和实际待解问题的模型之间的关联**。建立这种映射是费力的，而且这不属于编程语言所固有的功能，这使得程序难以编写，并且维护代价高昂，同时也产生了作为副产物的整个“编程方法”行业。

> 机器模型：位于“解空间”内，这是你对问题建模的地方，例如计算机
>
> 实际待解问题的模型：位于“问题空间”内，这是问题存在的地方，例如一项业务

另一种对机器建模的方式就是**只针对待解问题建模**。这些方式对于它们所要解决的特定类型的问题都是不错的解决方案，但是一旦超出其特定领域，它们就力不从心了。

OOP允许根据问题来描述问题，进一步提供表示问题空间中的元素的工具。这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。我们将**问题空间中的元素及其在解空间中的表示**称为“对象”。程序可以通过添加新类型的对象使自身适用于某个特定问题。

第一个OOP的五个基本特性：

1. 万物皆为对象。
2. 程序是对象的集合，它们通过发送消息来告知彼此所要做的。消息可理解为对某个特定对象的方法的调用请求。
3. 每个对象都有自己的由其他对象所构成的存储。
4. 每个对象都拥有其类型，即每个对象都是某个类（class）的一个实例（instance）
5. 某一特定类型的所有对象都可以接收同样的消息。这种可替代性（substitutability）是OOP中最强有力的概念之一。

## 1.2 每个对象都有一个接口

创建**抽象数据类型**（类）是面向对象程序设计的基本概念之一。抽象数据类型的运行方式与**内置（built-in）类型**几乎完全一致：你可以创建某一类型的变量（按照面向对象的说法，称其为对象或实例），然后操作这些变量（称其为发送消息或请求；发送消息，对象就知道要做什么）。

类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个**数据类型**。程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。

面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间**创建一对一的映射**。

怎样才能获得有用的对象呢？必须有某种方式产生对对象的请求，使对象完成各种任务。每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。

> P.S. UML形式的图（Unified Modelling Language，统一建模语言）
>
> 每个类都用一个方框表示，类名在方框的顶部，所关心的任何数据成员都描述在方框的中间部分，方法（隶属于此对象的、用来接收你发给此对象的消息的函数）在方框的底部。
>
> 通常，只有类名和公共方法被示于UML设计图中。

## 1.3　每个对象都提供服务

将对象想像为“服务提供者”。

程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。你的目标就是去**创建（或者最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象**。

> tips：将问题分解为对象集合的一种合理方式
>
> 对于那些并不存在的对象，它们看起来像什么样子？它们能够提供哪些服务？它们需要哪些对象才能履行它们的义务？如果持续这样做，那么最终你会说“那个对象看起来很简单，可以坐下来写代码了”，或者会说“我肯定那个对象已经存在了”。

将对象看作是服务提供者还有一个附带的好处：有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一：这意味着一个软件构件的各个方面**“组合”得很好**。在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。

## 1.4　被隐藏的具体实现

> 程序开发人员按照角色分类：
>
> 1. 类创建者：那些创建新数据类型的程序员，目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。
> 2. 客户端程序员：那些在其应用中使用数据类型的类消费者，目标是收集各种用来实现快速应用开发的类。

在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。

访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分——这些部分对数据类型的内部操作来说是必需的，但并不是用户解决特定问题所需的接口的一部分。

访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。

Java用三个关键字在类的内部设定边界：**public、private、protected**。

- public表示紧随其后的元素对任何人都是可用的
- private表示除**类型创建者和类型的内部方法**之外的任何人都不能访问的元素。
- protected关键字与private作用相当，差别仅在于**继承的类**可以访问protected成员，但是不能访问private成员。

Java还有一种默认的访问权限——包访问权限：当没有使用前面提到的任何访问指定词时，它将发挥作用。在这种权限下，类可以访问在同一个包（库构件）中的其他类的成员，但是在包之外，这些成员如同指定了private一样。

## 1.5　复用具体实现

代码复用是面向对象程序设计语言所提供的最了不起的优点之一。

最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。

新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为**组合**（composition），如果组合是动态发生的，那么它通常被称为**聚合**（aggregation）。组合经常被视为“has-a”（拥有）关系。

组合带来了极大的灵活性。新类的成员对象通常都被声明为private，使得使用新类的客户端程序员不能访问它们。

下面将要讨论的继承并不具备这样的灵活性，因为**编译器必须对通过继承而创建的类施加编译时的限制**【不是很懂】。继承虽然在OOP中非常重要，但实际上，在建立新类时，应该**首先考虑组合**，因为它更加简单灵活。如果采用这种方式，设计会变得更加清晰。一旦有了一些经验之后，便能够看出必须使用继承的场合了。

## 1.6　继承

继承：以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类。

当源类（被称为基类、超类或父类）发生变动时，被修改的“副本”（被称为导出类、继承类或子类）也会反映出这些变动。

类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与**其他类型之间的关系**。继承使用基类型和导出类型的概念表示了这种类型之间的相似性。一个基类型包含其所有导出类型所共享的特性和行为。可以创建一个基类型来表示系统中某些对象的**核心概念**，从基类型中导出其他类型，来表示此核心**可以被实现的各种不同方式**。

以同样的术语将解决方案转换成问题是大有裨益的，因为不需要在问题描述和解决方案描述之间建立许多**中间模型**。通过使用对象，**类型层次结构**成为了主要模型。事实上，对使用面向对象设计的人们来说，困难之一是**从开始到结束过于简单**。

当继承现有类型时，它也复制了基类的接口。这也就意味着导出类与基类具有相同的类型。通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。

有两种方法可以使基类与导出类产生差异。

- 直接在导出类中添加新方法。

  这种设计的发现与迭代过程在面向对象程序设计中会经常发生。但是，应该仔细考虑是否存在基类也需要这些额外方法的可能性。

  在这种情况下，导出类型扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这时基类与导出类之间的关系为**is-like-a（像是一个）关系**。

- 改变现有基类的方法的行为，这被称之为**覆盖**（overriding）。

  直接在导出类中创建该方法的新定义即可实现覆盖。

  此时导出类和基类是完全相同的类型，因为它们具有完全相同的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为**纯粹替代**，通常称之为**替代原则**。这时基类与导出类之间的关系为**is-a（是一个）关系**。

判断是否继承，就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。

## 1.7　伴随多态的可互换对象

在处理类型的层次结构时，经常想把一个对象不当作它所属的特定类型来对待，而是**将其当作其基类的对象**来对待。这使得人们可以编写出**不依赖于特定类型的代码**。这样的代码是**不会受添加新类型影响**的。

> 添加新类型是扩展一个面向对象程序以便处理新情况的最常用方式。
>
> 通过导出新的子类型而轻松扩展设计的能力是对改动进行封装的基本方式之一。

如果某个方法要让泛化几何形状绘制自己、让泛化交通工具行驶，或者让泛化的鸟类移动，那么**编译器在编译时是不可能知道应该执行哪一段代码的**。这就是关键所在：当发送这样的消息时，程序员并不想知道哪一段代码将被执行；绘图方法可以被等同地应用于圆形、正方形、三角形，而对象会**依据自身的具体类型来执行恰当的代码**。

如果不需要知道哪一段代码会被执行，那么当添加新的子类型时，不需要更改调用它的方法，它就能够执行不同的代码。

因此，编译器不可能产生传统意义上的函数调用。

一个非面向对象编程的编译器产生的函数调用会引起所谓的**前期绑定**，这么做意味着编译器将产生**对一个具体函数名字的调用**，而运行时将这个调用解析到将要被执行的代码的**绝对地址**。

在OOP中，程序直到运行时才能够确定代码的地址，为了解决这个问题，面向对象程序设计语言使用了**后期绑定**的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言被称为是弱类型的），但是并不知道将被执行的确切代码。

为了执行后期绑定，Java使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。

在Java中，**动态绑定是默认行为**，不需要添加额外的关键字来实现多态。并称这一类程序是**可扩展的**。

将导出类看做是它的基类的过程称为**向上转型**（upcasting）。一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。

正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你需要马上知道的只是事情会发生，更重要的是怎样通过它来设计。当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。

## 1.8　单根继承结构

在在Java的OOP中，所有的类最终都继承自单一的基类——Object。

- 在单根继承结构中的所有对象都具有一个**共用接口**，所以它们归根到底都是相同的基本类型。
- 单根继承结构保证所有对象都具备某些功能。因此，在系统中你可以在每个对象上执行某些基本操作。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。
- 单根继承结构使**垃圾回收器的实现**变得容易得多。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。

## 1.9　容器

如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。但是这类信息只有在运行时才能获得。

对于面向对象设计中的大多数问题而言，这个问题的解决方案似乎过于轻率：**创建另一种对象类型**。这种新的对象类型持有对其他对象的引用。这个新对象通常被称为”容器“，在任何需要时都可扩充自己以容纳你置于其中的所有东西。因此不需要知道将来会把多少个对象置于容器中，**只需要创建一个容器对象**，然后让它处理所有细节。

好的OOP语言都有一组容器，它们作为开发包的一部分。在Java中，具有满足不同需要的各种类型的容器，例如List（用于存储序列），Map（也被称为关联数组，用来建立对象之间的关联），Set（每种对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件。

从设计的观点来看，真正需要的只是一个**可以被操作，从而解决问题的序列**。

需要对容器有所选择，这有两个原因。

- 第一，不同容器提供了不同类型的接口和外部行为。它们之中的某种容器提供的解决方案可能比其他容器要灵活得多。
- 第二，不同的容器对于某些操作具有不同的效率。

> 我们可以在一开始使用LinkedList构建程序，而在优化系统性能时改用ArrayList。

### 1.9.1 参数化类型

在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。要使用这样的容器，只需在其中置入对象引用，稍后还可以将它们取回。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会**丢失其身份**。当把它取回时，就获取了一个对Object对象的引用，而不是对置入时的那个类型的对象的引用。

那么怎样才能将它变回先前置入容器中时的具有实用接口的对象呢？**向下转型**为更具体的类型。

除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的。然而向下转型并非彻底是危险的，因为如果向下转型为错误的类型，就会得到被称为异常的运行时错误。尽管如此，当从容器中取出对象引用时，还是必须要以某种方式记住这些对象究竟是什么类型，这样才能执行正确的向下转型。这导致向下转型和运行时的检查需要额外的程序运行时间，也需要程序员付出更多的心血。

解决方案：参数化类型机制。

参数化类型就是一个编译器可以自动定制作用于特定类型上的类，在Java中它称为**范型**。一对尖括号，中间包含类型信息，通过这些特征就可以识别对范型的使用。

## 1.10　对象的创建和生命期

1. 在使用对象时，最关键的问题之一便是它们的**生成和销毁方式**。

每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。

Q：怎样才能知道何时销毁这些对象呢？当处理完某个对象之后，系统某个其他部分可能还在处理它。

为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定，这可以通过将对象置于**堆栈**（它们有时被称为自动变量（automatic variable）或限域变量（scoped variable））或**静态存储区域**内来实现。这种方式**将存储空间分配和释放置于优先考虑的位置**，某些情况下这样控制非常有价值。但是，也**牺牲了灵活性**，因为必须在编写程序时知道对象确切的数量、生命周期和类型。

第二种方式是在被称为**堆**（heap）的**内存池**中**动态地创建对象**。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们的具体类型是什么。

如果需要一个新对象，可以在需要的时刻直接在堆中创建。因为存储空间是在运行时被动态管理的，所以需要**大量的时间**在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈中创建存储空间和释放存储空间通常各需要**一条汇编指令**即可，分别对应将栈顶指针向下移动和将栈顶指针向上移动。创建堆存储空间的时间依赖于**存储机制的设计**。

动态方式有这样一个**一般性的逻辑假设**：对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。动态方式所带来的更大的灵活性正是解决一般化编程问题的要点所在。

Java完全采用了动态内存分配方式 。每当想要创建新对象时，就要使用**new关键字**来构建此对象的动态实例。



2. 对象生命周期。

对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁它。然而，如果是在堆上创建对象，编译器就会对它的生命周期一无所知。

Java提供了被称为“**垃圾回收器**”的机制，用来处理内存释放问题。它可以自动发现对象何时不再被使用，并继而销毁它。垃圾回收器非常有用，因为它减少了所必须考虑的议题和必须编写的代码。更重要的是，垃圾回收器提供了更高层的保障，可以避免暗藏的内存泄漏问题。

## 1.11　异常处理：处理错误

异常处理将错误处理直接置于编程语言中，有时甚至置于操作系统中。异常是一种**对象**，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径，它不会干扰正常的执行代码。

此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。**异常不能被忽略**，所以它保证一定会在某处得到处理。最后需要指出的是：异常提供了一种从错误状况进行可靠恢复的途径。

Java一开始就内置了异常处理，而且强制你必须使用它。

## 1.12　并发编程

在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后再返回主进程。

> 最初是通过硬件中断来触发的。

有时中断对于处理时间性强的任务是必需的，但是对于大量的其他问题，我们只是想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些**彼此独立运行**的部分称之为**线程**，上述概念被称为“**并发**”。并发最常见的例子就是用户界面。通过使用任务，用户可以在揿下按钮后快速得到一个响应，而不用被迫等待到程序完成当前任务为止。

通常，线程只是一种为单一处理器分配执行时间的手段。但是如果操作系统支持多处理器，那么每个任务都可以被指派给不同的处理器，并且它们是在真正地并行执行。因此，程序员不用再操心机器上是有多个处理器还是只有一个处理器。

并发有一个隐患：**共享资源**。如果有多个并行任务都要访问同一项资源，那么就会出问题。为了解决这个问题，**可以共享的资源必须在使用期间被锁定**。因此，整个过程是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。

## 1.13　Java与Internet

尽管Java对于解决传统的单机程序设计问题非常有用，但同样重要的是，它解决了在万维网（WWW）上的程序设计问题。

### 1.13.1　Web是什么

1. 客户/服务器计算技术

客户/服务器系统的**核心思想**是：系统具有一个中央信息存储池（central repository of information），用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。

客户/服务器概念的**关键**在于信息存储池的位置集中于中央，这使得它可以被修改，并且这些修改将被传播给信息消费者。

信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为**服务器**。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为客户机的用户机器上。

你只有单一的服务器，却要同时为多个客户服务。通常，这会涉及**数据库管理系统**。此外，系统通常允许客户在服务器中插入新的信息。这意味着必须保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失（这被称为**事务处理**）。如果客户端软件发生变化，那么它必须被**重新编译、调试并安装到客户端机器**上，事实证明这比想像的要更加复杂与费力。如果想支持多种不同类型的计算机和操作系统，问题将更麻烦。最后还有一个最重要的性能问题：可能在任意时刻都有成百上千的客户向服务器发出请求，所以任何小的延迟都会产生重大影响。为了将**延迟最小化**，程序员努力减轻处理任务的负载，通常是**分散给客户端机器处理**，但有时也会使用所谓的**中间件**将负载分散给在服务器端的其他机器。（中间件也被用来提高**可维护性**。）

客户/服务器计算技术大概占了所有程序设计行为的一半。

2. Web就是一台巨型服务器

Web实际上就是一个巨型客户/服务器系统，但稍微差一点，因为所有的服务器和客户机都同时共存于同一个网络中。但你所要关心的只是在某一时刻怎样连接到一台服务器上，并与之进行交互。

最初只有一种很简单的单向过程：你对某个服务器产生一个请求，然后它返回给你一个文件，你的机器（也就是客户机）上的浏览器软件根据本地机器的格式来解读这个文件。但人们希望实现完整的客户/服务器能力，使得客户可以将信息反馈给服务器。

Web浏览器向前跨进了一大步，它包含了这样的概念：一段信息不经修改就可以在任意型号的计算机上显示。然而，最初的浏览器仍然相当原始，很快就因为加诸于其上的种种需要而陷入困境。浏览器并不具备显著的交互性，而且它趋向于使服务器和Internet阻塞，因为在任何时候，只要你需要完成通过编程来实现的任务，就**必须将信息发回到服务器去处理**。因为浏览器只是一个**观察器**，因此它甚至不能执行最简单的计算任务。（另一方面，它却是安全的，因为它在你的本地机器上不会执行任何程序，而这些程序有可能包含bug和病毒。）

为了解决这个问题，人们采用了各种不同的方法。首先，**图形标准得到了增强**，使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引入在客户端浏览器中运行程序的能力就可以解决。这被称为“**客户端编程**”。

### 1.13.2　客户端编程

Web最初的“服务器-浏览器”设计是为了能够提供**交互性**的内容，但是其交互性完全由**服务器**提供。服务器产生静态页面，提供给只能解释并显示它们的客户端浏览器。

基本的HTML（HyperText Markup Language，超文本标记语言）包含有简单的数据收集机制：文本输入框、复选框、单选框、列表和下拉式列表以及按钮——它只能被编程来实现**复位表单上的数据或提交表单上的数据给服务器**。这种提交动作通过所有的Web服务器都提供的**通用网关接口**（common gateway interface, CGI）传递。最常见的动作就是运行一个在服务器中常被命名为“**cgi-bin**”的目录下的一个程序。

当今许多有影响力的网站完全构建于CGI之上的，然而，构建于CGI程序之上的网站可能会迅速变得过于复杂而难以维护，并同时产生响应时间过长的问题。CGI程序的响应时间依赖于所必须发送的数据量的大小，以及服务器和Internet的负载。

Web的最初设计者们并没有预见到**网络带宽**被人们开发的各种应用迅速耗尽。例如，任何形式的动态图形处理几乎都不可能连贯地执行，因为图形交互格式（graphic interchange format, GIF）的文件必须在服务器端创建每一个图形版本，并发送给客户端。

问题的解决方法就是客户端编程。客户端编程意味着Web浏览器能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅捷，而且使得你的网站更加具有交互性。

客户端编程的问题是：它与通常意义上的编程十分不同，参数几乎相同，而**平台**却不同。Web浏览器就像一个**功能受限的操作系统**。最终，你仍然必须编写程序，而且还得处理那些令人头晕眼花的成堆的问题，并以客户端编程的方式来产生解决方案。

1. 插件

客户端编程所迈出的最重要的一步就是插件（plug-in）的开发。通过这种方式，程序员可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器添加新功能。

插件对于客户端编程的价值在于：它允许专家级的程序员不需经过浏览器生产厂商的许可，就可以**开发某种语言扩展**，并将它们添加到服务器中。

2. 脚本语言

插件引发了浏览器脚本语言（scripting language）的开发。通过使用某种脚本语言，你可以将客户端程序的源代码直接嵌入到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。

脚本语言先天就**相当易于理解**，因为它们只是作为HTML页面一部分的简单文本，当服务器收到要获取该页面的请求时，它们可以被快速加载。此方法的缺点是代码会**暴露给任何人去浏览**（或窃取）。但是，通常不会使用脚本语言去做相当复杂的事情，所以这个缺点并不太严重。

- JavaScript

在Web浏览器不需要任何插件的情况下就可以得到支持的一种脚本语言

大多数Web浏览器最初都是以彼此相异的方式来实现对JavaScript的支持的，这种差异甚至存在于同一种浏览器的不同版本之间。通常，你必须以JavaScript的某种最小公分母形式来编程，以使得你的程序可以在所有的浏览器上运行。

在Web浏览器内部使用的脚本语言实际上总是被用来解决特定类型的问题，主要是用来创建更丰富、更具有交互性的图形化用户界面（graphic user interface, GUI）。但是，脚本语言可以解决客户端编程中所遇到的**百分之八十**的问题。你的问题可能正好落在这百分之八十的范围之内，由于脚本语言提供了更容易、更快捷的开发方式，因此你应该在考虑诸如Java这样的更复杂的解决方案之前，**先考虑脚本语言**。

3. Java

用于解决客户端编程剩下那百分之二十的问题。

Java是通过applet以及使用Java Web Start来进行客户端编程的。

- applet

applet是只在Web浏览器中运行的小程序，它是作为网页的一部分而自动下载的。

当applet被激活时，它便开始执行一个程序，这正是它优雅之处：它提供一种分发软件的方法，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。用户获取最新版本的客户端软件时不会产生错误，而且也不需要很麻烦的重新安装过程。这不仅立即就获得了高速度和快速的响应能力，而且也降低了网络流量和服务器负载，从而不会使整个Internet的速度都慢了下来。

4. 备选方案

无论何时，只要你想控制用户的机器，使用上述这些技术来发布和更新客户端应用就显得非常恰当，并且这可以节省大量的时间、人力和财力，特别是你需要频繁地更新的时候。

- Macromedia的Flex，它允许你创建基于Flash的与applet相当的应用。
- 基于ECMAScript的ActionScript语言

Flex使得我们在编程时无需担心浏览器相关性，因此，它远比JavaScript要吸引人得多。对于客户端编程而言，这是一种值得考虑的备选方案。

5. . NET和C#

微软以.NET平台和C#编程语言的形式推出了与Java全面竞争的对手。.NET平台大致相当于Java虚拟机（JVM，即执行Java程序的软件平台）和Java类库，而C#毫无疑问与Java有类似之处。（他们可以看得到Java在什么方面做得好，在什么方面做得还不够好，然后基于此去构建，并要具备Java不具备的优点。）

目前，.NET主要受攻击的地方和人们所关心的最重要的问题就是，微软是否会允许将它完全地移植到其他平台上。微软宣称这么做没有问题，而且Mono项目已经有了一个在Linux上运行的.NET的部分实现；但是，在该实现完成及微软不会排斥其中的任何部分之前，.NET作为一种跨平台的解决方案仍旧是一场高风险的赌博。

6. Internet与Intranet

如果采用传统的客户/服务器方式，可能会遇到客户端计算机有多种型号的问题，也可能会遇到安装新的客户端软件的麻烦，而它们都可以很方便地通过**Web浏览器和客户端编程**得以解决。

当Web技术仅限用于特定公司的信息网络时，它就被称为**Intranet（企业内部网）**。Intranet比Internet提供了更高的**安全性**，因为可以物理地控制对公司内部服务器的访问。

如果程序运行在Internet之上，那么就不可能知道它将运行在什么样的平台之上，因此，要格外小心，不要传播有bug的代码。你需要跨平台的、安全的语言，就像脚本语言和Java。

如果程序运行与Intranet上，那么可能会受到不同的限制。企业内所有的机器都采用Intel/Windows平台并不是什么稀奇的事。在Intranet上，你可以对你自己的代码质量负责，并且在发现bug之后可以修复它们。此外，你可能已经有了以前使用更传统的客户/服务器方式编写的遗留代码，因此，你必须在每一次升级时都要**物理地重装客户端程序**。在**安装升级程序时所浪费的时间**是迁移到浏览器方式上的最主要的原因，因为在浏览器方式下，升级是透明的、自动的。如果你身处这样的Intranet之中，那么最有意义的方式就是选择一条能够**使用现有代码库的最短的捷径**，而不是用一种新语言重新编写你的代码。

当面对各种令人眼花缭乱的解决客户端编程问题的方案时，最好的方法就是进行**性价比分析**。认真考虑问题的各种限制，然后思考哪种解决方案可以成为**最短的捷径**。既然客户端编程仍然需要编程，那么针对自己的特殊应用选取**最快的开发方式**总是最好的做法。为那些在程序开发中不可避免的问题提早作准备是一种积极的态度。

### 1.13.3　服务器端编程

更复杂的对服务器的请求通常涉及数据库事务。常见的情形是复杂的数据库搜索请求，然后服务器将结果进行格式编排，使其成为一个HTML页面发回给客户端。这些数据库请求必须通过服务器端的某些代码来处理，这就是所谓的**服务器端编程**。

其中就包括基于Java的Web服务器，它让你用Java编写被称为**servlet**的程序来实现服务器端编程。servlet及其衍生物**JSP**，是许多开发网站的公司迁移到Java上的两个主要的原因，尤其是因为它们消除了处理具有不同能力的浏览器时所遇到的问题。

## 1.14 总结

OOP和Java也许并不适合所有的人。重要的是要正确评估自己的需求，并决定Java是否能够最好地满足这些需求，还是使用其他编程系统才是更好的选择。
