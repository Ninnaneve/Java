## 13.1 包装类 

包装类的分类：

1) 针对八种基本数据类型相应的引用类型—包装类 
2) 有了类的特点，就可以调用类中的方法

![image-20220709094224380](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220709094224380.png)

---

包装类和基本数据的转换：

- jdk5前的手动装箱和拆箱方式，装箱：基本类型 -> 包装类型，反之则是拆箱

```java
// 手动装箱
int n1 = 100;
Integer integer1 = new Integer(n1);
Integer integer2 = Integer.valueOf(n1);

//手动拆箱
int i = integer.intValue();
```

- jdk5及以后的自动装箱和拆箱方式

```java
//自动装箱
int n2 = 200;
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)

//自动拆箱
int n3 = integer2; 
```

- 自动装箱底层调用的是valueOf方法
- 其它包装类的用法类似



例题，下列语句输出结果？

```java
Object obj1 = true? new Integer(1): new Double(2.0);
```

结果为1.0，因为三元运算符是一个整体，会自动转型成精度最高的输出，因此为1.0而非1。但是if else就是分别计算的。

注意：这里的true是判断条件！

----

包装类型和 String 类型的相互转换：

```java
//包装类(Integer)->String
Integer i = 100; //自动装箱
String str1 = i + "";
String str2 = i.toString();
String str3 = String.valueOf(i); 

//String -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4); // 返回的是int，使用到自动装箱
Integer i3 = new Integer(str4); // 构造器，可以直接传入字符串
Integer i4 = Integer.valueOf(str4);
```

Integer 类和 Character 类的常用方法：

```java
System.out.println(Integer.MIN_VALUE); //返回最小值
System.out.println(Integer.MAX_VALUE);//返回最大值

System.out.println(Character.isDigit('a'));//判断是不是数字
System.out.println(Character.isLetter('a'));//判断是不是字母
System.out.println(Character.isUpperCase('a'));//判断是不是大写
System.out.println(Character.isLowerCase('a'));//判断是不是小写

System.out.println(Character.isWhitespace('a'));//判断是不是空格
System.out.println(Character.toUpperCase('a'));//转成大写
System.out.println(Character.toLowerCase('A'));//转成小写
```



经典面试题：下列语句输出结果？

```java
// 1
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j); //False

// 2、3
Integer m = 127; //底层 Integer.valueOf(127); -> 阅读源码，见下
Integer n = 127;//底层 Integer.valueOf(127);
System.out.println(m == n); //T


Integer x = 128;//底层 Integer.valueOf(128);
Integer y = 128;//底层 Integer.valueOf(128);
System.out.println(x == y);// F

/*
// 源码
public static Integer valueOf(int i) {
if (i >= IntegerCache.low && i <= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
}

解读:
1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回（这些数在类加载时就已经创建好了。类似Python中的缓存池：这些数字都有对应确定的缓存地址。引用时无需创建，直接引用即可）
2. 如果不在 -128~127，就直接 new Integer(i)
*/

// 4
Integer i9 = 127; // Integer.valueOf(127)
Integer i10 = new Integer(127);
System.out.println(i9 == i10);//F

// 一个是返回IntegerCache数组，一个是通过构造器构造Integer对象，肯定不是同一个

// 5、6
Integer i11 = 127;
int i12 = 127;
System.out.println(i11 == i12); //T

Integer i13 = 128;
int i14 = 128;
System.out.println(i13 == i14);//T

// 和基本数据类型进行比较时，包装类会调用方法（如intValue()）返回值，最终判断的是值是否相同
```



## 13.2 String 类 

String 类的理解和创建对象：

- String对象用于保存字符串也就是一组字符序列
- 字符串常量对象是用双括号引起的字符序列，如"Jess"
- 字符串的字符使用Unicode字符编码一个字符（不区分字母还是汉字）占两个字节
- String类有许多常用构造器（其它看手册），实现了类的重载：
  - String s1 = new String();
  - String s2 = new String(String original);
  - String s3 = new String(char[] a);
  - String s4 = new String(char[] a, int startIndex, int count);
  - String s5 = new String(byte[] b);
- String 类实现了接口 Serializable，使String 可以串行化，即可以保存到文件或者实现网络传输，还实现了接口 Comparable，使String 对象可以比较大小

![image-20220709105902697](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220709105902697.png)

- String 是 final 类，不能被其他的类继承
- String 本质还是一个char数组，String有属性 private final char value[]; 用于存放字符串内容
  - 一定要注意：value 是一个 final 类型， 不可以修改，这里修改指的是 value 不能指向新的地址，但是其指向的数组内容还是可以变化的

---

创建 String 对象的两种方式与区别：

- 方式一：直接赋值，如String s = "hsp";
  先从常量池中查看是否有“hsp”数据空间，如果有，则直接指向；如果没有，则重新创建，然后指向。s最终指向的是常量池的空间地址。
- 方式二：调用构造器，如String s = new String("hsp");
  先在堆中创建空间，里面维护了value属性（即上述的value[]），指向常量池的空间。如果常量池没有“hsp”，就重新创建，如果有，直接通过value指向，最终指向的是堆中的空间地址。

![2022-07-09_11-29-05](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/2022-07-09_11-29-05.jpg)



P.S. String.intern()：返回常量池的地址。若常量池存在相同字符串（用equals方法确定），则返回常量值对应地址；若不存在，则将此对象添加到常量池中，并返回对象的引用地址

```java
String a = "hsp";
String b = new String("hsp");
sout(a == b.intern()); // T
sout(b == b.intern()); // F

Person p1 = new Person();
p1.name = "hsp";
sout(p1.name == "hsp"); // T，因为"hsp"不是new出来的，底层就是常量池中对应字符串的地址
```



## 13.3 字符串的特性
- 字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。
  - 因为value是private的，并且没有提供setValue等公共方法来修改这些值，所以在String类的外部无法修改String。也就是说一旦初始化就不能修改， 并且在String类的外部不能访问这个成员。
  - 此外，value这个变量是final的， 也就是说在String类内部，一旦值初始化了， 就不能被改变。所以可以认为String对象是不可变的了。
  - 但是注意，value属性是引用类型，final修饰后不能再指向其它对象，但可以改变value指向的数组元素。一般情况下，由于private的限制无法更改，但可以通过反射来更改，不过不推荐使用。（暂时超纲了）

> 在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。
>
> ——参考文章：https://blog.csdn.net/zhangjg_blog/article/details/18319521



面试题：以下语句创建了几个对象？

```java
String s1 = "hello";
s1 = "ciao";
```

2个。这里是因为忘记直接赋值就直接指向常量池了。

```java
String a = "hello" + "abc";
```

1个。编译器会自己做优化，会判断创建的常量池对象是否有引用指向。

```java
String a = "hello";
String b = "abc";
String c = a + b;
```

3个。

关键是分析String c = a + b;到底是如何执行的：

1. 创建一个StringBuilder sb = new StringBuilder();
2. 执行sb.append(a);
3. 执行sb.append(b);（append是在原来字符串的基础上追加的）
4. 得到String c = sb.toString();，最后其实是c指向堆中的对象(String) value[]，其指向池中的"helloabc"

> 规则：全常量相加看池，有变量相加在堆。（有变量即只要有一个变量）
>
> 学习思想：一定尽量看源码学习。



面试题2：下列程序的运行结果是什么？

```java 
class Test1 {
    String str = new String("hsp");
    final char[] ch = {'j', 'a', 'v', 'a'};

    public void change(String str, char ch[]) {
        str = "java";
        ch[0] = 'h';
    }

    public static void main(String[] args) {
        Test1 ex = new Test1();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.println(ex.ch);
    }
}
```

自己的主要错误点：

1. 对象str在堆中指向String中的value[]属性，然后再由value[]属性指向常量池；
2. 对象ch在堆中指向给数组存放值的一块空间；
3. 在main方法调用方法会开辟一个新栈；
4. 方法传入ex.str, ex.ch时，属于局部变量，与Test对象属性无关，指向的仍是上述空间；
5. str = "java";直接断开了原有连接，而去指向常量池，相当于字符串的直接赋值；
6. 最后ex.str仍然指向原有的value[]属性。

![2022-07-09_14-09-11](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/2022-07-09_14-09-11.jpg)



## 13.4 String类常见方法
String类是保存字符串常量的，每次更新都需要开辟新空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能并提高效率。

String 类的常见方法（只知道怎么用即可）：

- equals：比较内容是否相同，区分大小写

- equalsIgnoreCase：忽略大小写的判断内容是否相等

- length：获取字符的个数，字符串的长度

- indexOf：获取字符/字符串在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1

- lastIndexOf：获取字符/字符串在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1

- substring：截取指定范围的子串，左闭右开。

  >  如a.substring(6)表示从索引6开始截取后面所有的内容；a.substring(0,5)表示从索引0开始截取，截取到第5个字符，

- trim：去前后空格

- charAt：获取某索引处的字符。

  > 注意：获取索引不能使用Str[index]这种方式，String不能用数组的取法！

- toUpperCase：转换成大写

- toLowerCase：转换成小写

- concat：拼接字符串。

  > concat与+的区别：
  >
  > - concat：使用Arrays对字符串进行拼接，并返回一个新String对象，原有对象保留
  >
  > ```java
  > public String concat(String str) {
  >     if (str.isEmpty()) {
  >         return this;
  >     }
  >     int len = value.length;
  >     int otherLen = str.length();
  >     char buf[] = Arrays.copyOf(value, len + otherLen);
  >     str.getChars(buf, len);
  >     return new String(buf, true);
  > }
  > ```
  >
  > - +：对于常量，直接拼接成一个新对象，原有对象丢弃；对于变量，使用StringBuilder sb = new StringBuilder();，sb.append(a);，sb.append(b);，String c = sb.toString();返回一个新String对象，原有对象保留

- replace：替换字符串中的所有字符

  > 注意：替换对原字符没有任何影响，因为源码没有return一个新的String对象，从而把原有对象引用替换了
  >
  > ```java
  > public String replace(CharSequence target, CharSequence replacement) {
  >     return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(
  >         this).replaceAll(Matcher.quoteReplacement(replacement.toString()));
  > }
  > ```
  >
  > 

- split：分割字符串，对于某些分割字符，我们需要加入转义符

- toCharArray：转换成字符

- compareTo：比较两个字符串的大小。

  - 如果长度相同，并且每个字符也相同，就返回 0
  - 如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回 if (c1 != c2) { return c1 - c2; } 
  - 如果前面的部分都相同，但是长度不同，就返回 str1.len - str2.len

- format：格式字符串

  - %s , %d , %.2f, %c 称为占位符，这些占位符由后面变量来替换
    - %s 表示由字符串来替换 
    - %d 表示由整数来替换
    - %.2f 表示由小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 
    - %c 使用 char

  ```java
  String name = "john";
  int age = 10;
  double score = 56.857;
  char gender = '男';
  String formatStr = "我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！";
  String info2 = String.format(formatStr, name, age, score, gender);
  ```

  

## 13.5 StringBuffer 类

基本介绍：

- java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删，其很多方法与String相同，但StringBuffer是**可变长度**的。

- StringBuffer是一个容器。
- StringBuffer 的直接父类 是 AbstractStringBuilder 
- StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 
- 在父类中 AbstractStringBuilder 有属性 char[] value，注意不是 final类型的。该 value 数组存放字符串内容，因此是存放在堆中的，而不是再常量池中。
- StringBuffer 是一个 final 类，不能被继承
- 因为 StringBuffer 字符内容是存在 char[] value中的, 所有在变化(增加/删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String。

----

String VS StringBuffer：

- String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址（即在常量池新增一个地址），效率较低 // private final char value[];

- StringBuffer保存是的字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高 // char[] value;

  > 只有在StringBuffer内存不够的时候才会更新地址

---

StringBuffer 类构造器：

- StringBuffer()：构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。
- StringBuffer(CharSequence seq)：public java.lang.StringBuilder(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的  CharSequence 相同的字符。
- StringBuffer(int capacity)：构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定。
- StringBuffer(String str)：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容，char[] 的大小就是str.len + 16。

----

StringBuffer 和 String 的相互转换：

- String——>StringBuffer

  - 方式1 使用构造器

    ```java
    String str = "hello tom";
    StringBuffer stringBuffer = new StringBuffer(str);
    ```

    > 注意： 返回的才是StringBuffer对象，对str 本身没有影响

  - 方式2 使用append方法

    ```java
    StringBuffer stringBuffer1 = new StringBuffer();
    stringBuffer1 = stringBuffer1.append(str);
    ```

- StringBuffer ->String

  - 方式1 使用StringBuffer提供的 toString方法

  ```java
  StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");
  String s = stringBuffer3.toString();
  ```

  - 方式2 使用构造器

  ```java
  String s1 = new String(stringBuffer3);
  ```

---

StringBuffer类常见方法：

- 增 append(string)

  ```java
  StringBuffer s = new StringBuffer("hello")
  s.append("赵敏").append(100).append(true).append(10.5);
  System.out.println(s); // 输出的是一个对象（参考源码）
  ```

- 删 delete(start, end)，左闭右开

- 改 replace(start, end, string)，左闭右开，替换字符串可以和原有长度不等

- 查 indexOf(place)，查找指定的子串在字符串第一次出现的索引，如果找不到返回-1

- 插 insert(place, string)，在指定位置插入字符串，原来相应位置后的内容自动后移

- 获取长度 length(string)



例题，

```java
String str = null;// ok
StringBuffer sb = new StringBuffer(); //ok
sb.append(str);//需要看源码, 底层调用的是 AbstractStringBuilder 的 appendNull，会增加n, u, l, l四个字符 
System.out.println(sb.length());//4

System.out.println(sb);//null
//下面的构造器，会抛出NullpointerException
StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);
System.out.println(sb1);
```



P.S. 练习2（输入价格，格式化为千位制）对String和StringBuffer方法的巧妙使用值得反复思考。



## 13.6 StringBuilder 类 

基本介绍：

- 一个可变的字符序列。此类提供一个与String Buffer兼容的API，但不保证同步（StringBuilder不是线程安全的）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区**被单个线程使用**的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。
- 在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。

- StringBuilder 和 StringBuffer 均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。（参考StringBuffer基本介绍）
- StringBuilder 的方法，没有做互斥的处理，即没有synchronized关键字，因此推荐在单线程情况下使用

----

String、StringBuffer 和 StringBuilder 的比较：

- StringBuffer 和 StringBuilder 非常类似，均代表可变的字符串序列，而且方法也一样
- String：不可变字符序列，效率低，但是复用率高
- StringBuffer：可变字符序列，效率较高（增删）、线程安全
- StringBuilder：可变字符序列，效率最高、线程不安全
- String使用注意说明：若我们对String要做大量修改，则不要使用String

----

String、StringBuffer 和 StringBuilder 的选择：

- 如果字符存在大量修改操作
  - 一般使用StringBuffer或StringBuilder
  - 单线程使用StringBuilder
  - 多线程使用StringBuffer
- 若干字符串很少修改，被多个对象引用，使用String，比如配置信息等



## 13.7 Math 类

基本介绍：Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

方法一览(均为静态方法)：



## 13.8 Arrays 类



## 13.9 System 类



## 13.10 BigInteger 和 BigDecimal 类



## 13.11日期类

