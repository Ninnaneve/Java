## 10.1 类变量和类方法

### 10.1.1 类变量

类变量（静态变量、静态属性）是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

类变量最大的特点是会被该类所有的对象实例共享。

> 注意：若是JDK7及之前，静态变量放在方法区的静态域中；JDK8之后，静态域是放在堆中的，通过反射机制会加载一个Class对象实例，静态变量就保存在Class实例的尾部。但是静态变量无论在哪里，都不会影响静态变量的使用。



----

定义类变量基本语法：

```java
访问修饰符 static 数据类型 变量名; // 推荐
static 访问修饰符 数据类型 变量名; 
```



---

如何访问类变量：

- 类名.类变量名[推荐]
- 对象名.类变量名

前提：满足访问修饰符的访问权限和范围

---------------

类变量使用注意事项和细节讨论：

- 什么时候需要用类变量

  当需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量

- 类变量与实例变量（普通属性）的区别

  类变量是该类的所有对象共享的，而实例变量的每个对象独享的

- 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

- 类变量可以通过 类名.类变量名 或者 对象名.类变量名 来访问，前提是满足访问修饰符的访问权限和范围，但实例变量不能通过 类名.类变量名 方式访问

- 类变量可以用this（也可以用super），但是不推荐，因为this更适合表示类的一个实例变量

- 类变量在类加载的时候就初始化了，因此，即使没有创建对象，只要类加载了，就可以使用类变量了

- 类变量的生命周期是随类的加载开始，随类的消亡而销毁



### 10.1.2 类方法

类方法又叫静态方法。

类方法基本语法：

```java
访问修饰符 static 数据返回类型 方法名(){ }; // 推荐
static 访问修饰符 数据返回类型 方法名(){ }; 
```



-------

类方法的调用：

- 类名.类方法名[推荐]
- 对象名.类方法名

前提：满足访问修饰符的访问权限和范围

----

类方法经典的使用场景：

当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。

在程序员实际开发中，往往会将一些通用方法设计成静态方法，这样就不需要创建对象就可以使用了，比如打印一维数组、冒泡排序等。

------

类方法使用注意事项和细节讨论：

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区
2. 类方法可以通过类名调用，也可以通过对象名调用，前提是满足访问修饰符的访问权限和范围
3. 普通方法和对象有关，只能通过对象名调用，不能通过类名调用
4. 类方法中不允许使用和对象有关的关键字，如this和super，普通方法（成员方法）可以（类方法中无this参数，普通方法中隐含着this参数）
5. 类方法中只能访问静态变量或方法
6. 普通成员方法，既可以访问非静态成员，又可以访问静态成员



## 10.2 理解 main 方法语法

解释main方法的形式：public static void main(String[] args)

- main方法是虚拟机在调用

- 因为java虚拟机和main()方法不在同一个包，所以该方法的访问权限必须是public，java虚拟机才能调用类的main()方法

- java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static

- void即说明没有返回值

- main()方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数

  > 例如，java在命令行运行时输入：
  >
  > ```powershell
  > java Hello a b c
  > ```
  >
  > 此时，args = {"a", "b", "c"};

----

特别提示：

- 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。
- 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静 态成员，[举例说明]



## 10.3 代码块 

基本介绍：

代码块又称初始化块，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{}包装起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

----

基本语法：

```java
[修饰符]{
    代码
}
```

说明注意：

- 修饰符可选， 要写也只能写static
- 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块
- 逻辑语句可以为人格逻辑语句（输入、输出、方法调用、循环、判断等）
- ;可以写上，也可以省略

----

代码块的好处：

- 相当于另外一种形式的构造器（对构造器的补充机制），可以做到初始化的操作

- 如果多个构造器中都有重复的语句，可以抽取到初始化中，提高代码的重用性

  > 例如，
  >
  > ```java
  > {
  >     System.out.pringln("a");
  >     System.out.pringln("b");
  >     System.out.pringln("c");
  > }
  > // 下面是不同的构造器，不写了
  > ```
  >
  > 这里无论用哪一个构造器，都会先执行代码块中的内容，代码块调用的顺序优先于构造器



----

代码块使用注意事项和细节讨论：

- static代码也叫静态代码块，作用就是对类进行初始化，而且它随着**类的加载**而执行，并且只会**执行一次**。

- 类什么时候被加载（重要）
  - 创建对象实例时(new)
  - 创建子类对象实例，父类也会被加载，而且，父类先被加载，子类后被加载（就类似构造器）
  - 使用类的静态成员时
- 普通的代码块，在**创建对象实例**时，会被隐式调用。
  - 被创建一次，就会调用一次
  - 如果只是使用实例来调用类的静态成员时，普通代码块并不会执行
- 创建一个对象时，在一个类调用顺序为（重点、难点）：
  - 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按它们定义的顺序调用）
  - 调用普通代码块和普通属性初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)
  - 调用构造器/构造方法
- 构造器的最前面其实隐含了super()和调用本类的普通代码块；而静态相关的代码块、属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的
- 当创建一个子类对象时（继承关系），它们的静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：
  - 进行类的加载
    - 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
    - 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
  - 创建对象 -> super()
    - 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
    - 父类的构造方法
  - 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
  - 子类的构造方法
- 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员



## 10.4 单例设计模式 

什么是设计模式?

- 静态方法和属性的经典使用
- 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考模式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索

--------

什么是单例模式？

- 单例设计模式就是采取一定的方法保证再整个软件系统中，对某个类只能存在一个对象实例，并且该类只提高一个取得对象实例的方法

- 单例模式有两种方式

  - 饿汉式（有可能没有使用这个对象，但只要类加载，对象就创建了）

    1. 构造器私有化 -> 防止直接new
    2. 类的内部创建一个静态属性对象实例（静态公共方法只能调用静态成员）
    3. 提供一个静态的公共方法（若不是静态，则需要new），返回内部创建的对象实例

    ```java
    class GirlFriend {
    	private String name;
        private static GirlFriend gf = new GirlFriend("小红红");
    
        private GirlFriend(String name) {
            System.out.println("构造器调用...");
            this.name = name;
        }
        public static GirlFriend getInstance() {
        	return gf;
        }
    }
    ```

    

  - 懒汉式（要使用对象，就创建一个实例）

    1. 构造器私有化 -> 防止直接new
    2. 定义一个静态属性对象，默认为null
    3. 提供一个静态的公共方法，会判断是否创建一个对象，第一次使用会创建，后面使用则会返回第一次创建的对象

    ```java
    class Cat {
        private String name;
        private static Cat cat ; //默认是 null
    
        private Cat(String name) {
            System.out.println("构造器调用...");
            this.name = name;
        }
        
        public static Cat getInstance() {
            if(cat == null) {
            	cat = new Cat("小可爱");
            }
            return cat;
    	}
    }
    ```



饿汉式 VS 懒汉式：

- 二者最主要的区别在于创建对象的时机是不同的：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建
- 饿汉式不存在线程安全问题，懒汉式存在线程安全问题
- 饿汉式存在资源浪费问题，懒汉式就不存在这个问题
- 在JavaSE标准类中，java,lang.Runtime就是经典的单例模式



## 10.5 final 关键字

基本介绍

某些情况下，程序员可能有以下需求，就会用到final：

- 不希望类被继承时
- 不希望父类的某个方法被子类覆盖/重写
- 不希望类的某个属性的值被修改，但可以被调用
- 不希望某个局部变量被修改

---------

final 使用注意事项和细节讨论：

- final修饰的属性又叫常量，一般用XX_XX_XX来命名

- final修饰的属性在定义时，必须赋初值，且以后不能修改。赋值可以在如下位置之一：

  - 定义时，如`public final double TAX_RATE = 0.8;`
  - 在构造器中
  - 在代码块中

- 如果final修饰的属性是静态的，在类加载时就需要被定义，则初始化位置只能是：

  - 定义时
  - 在静态代码块而不是构造器中赋值

- final类不能被继承，但是可以实例化对象

- 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承，即仍然遵守继承机制

- 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法

- final不能修饰构造器

- final和static往往搭配使用，效率更高，因为**不会导致类加载**，其对底层编译器做了优化处理

  ```java
  // main方法
  System.out.println(BBB.num); // 最终输出：10000
  
  class BBB {
      public final static int num = 10000;
      static {
      	System.out.println("BBB 静态代码块被执行");
      }
  }
  ```

- 包装类（Integer, Double, Float, Boolean等都是final）， String也是final类



## 10.6 抽象类

当父类某些方法需要声明，但又不确定如何实现时，可以将其声明为抽象方法（即没有实现的方法），那么这个类就是抽象类。当一个类中存在抽象方法时，需要将该类声明为 abstract 类。一般来说，抽象类会被继承，有其子类来实现抽象方法。



抽象类的介绍：

- 用abstract关键字来修饰一个类时，这个类就叫抽象类

  ```java
  访问修饰符 abstract class 类名{
  }
  ```

- 用abstract关键字来修饰一个方法时，这个方法就是抽象方法

  ```java
  访问修饰符 abstract 返回类型 方法名(参数列表); // 没有方法体
  ```

- 抽象类的价值更多在于设计，即设计者设计好后，让子类继承并实现抽象类

- 抽象类是面试爱问的知识点，在框架和设计模式使用较多

------

抽象类使用的注意事项和细节讨论：

- 抽象类不能被实例化

- 抽象类可以没有abstract方法

- 一旦类包含了abstract方法，则这个类必须声明为abstract

- abstract只能修饰类和方法，不能修饰属性和其它的

- 抽象类可以有任意成员（因为抽象类的本质还是类），比如非抽象方法、构造器、静态(static)属性等

- 抽象方法不能有主体，即不能实现

- 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类

- 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的

  > private方法不能重写。final不能继承。
  >
  > static关键字和方法重写无关。static方法满足能通过类调用，但通过了类调用已经实现了该方法，这和抽象方法不能实现相冲突。且抽象类不能被实例化，若通过类无法调用静态方法，那么这种静态方法肯定是不对的。



## 10.7 抽象类最佳实践-模板设计模式

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为模式。

模板设计模式能解决的问题：

- 当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现
- 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。



## 10.8 接口

接口就是给出关于一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

基本语法：

```java
interface 接口名{
    // 属性
    // 抽象方法
}

class 类名 implements 接口{
    自己属性;
    自己方法;
    必须实现的接口的抽象方法
}
```

接口是更加抽象的抽象类，抽象类里的方法可以有方法体。接口体现了程序设计的多态和高内聚低耦合的设计思想。

> 注意：
>
> 在JDK 7.0及之前，接口里的所有方法都没有方法体，即只能定义抽象方法。
>
> JDK8.0及之后接口类可以有静态方法、默认方法，即接口中可以有方法的具体实现。使用默认方法时，需要使用`default`关键字修饰。

--------

注意事项和细节：

- 接口不能被实例化

- 接口中所有的方法是`public`方法，接口中抽象方法，可以不用abstract修饰，比如`void aaa();`实际上是`abstract void aaa();`

- 一个普通类实现接口，就必须将该接口的所有方法都实现，可以使用`alt+enter`快捷键来实现

- 抽象类实现接口，可以不用实现接口的方法

- 一个类同时可以实现多个接口

- 接口中的属性，只能是final的，必须初始化，即只能是常量，而且是`public static final `修饰符，比如接口定义的属性`int a = 1; `实际上是`public static final int a = 1;`

  > public: 使接口的实现类可以使用这个常量。
  >
  > static：接口不涉及和任何具体实例相关的细节，因此接口没有构造方法，不能被实例化，故没有实例变量，只有静态变量。
  >
  > final：接口中不可以定义变量，即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。

- 接口中属性的访问形式：接口名.属性名

- 接口不能继承其它的类，但是可以继承多个别的接口，如`interface A extends B, C;`

- 接口的修饰符只能是public和默认，这点和类修饰符是一样的

------

实现接口 vs 继承：

- 接口和继承解决的问题不同
  - 继承的价值在于：解决代码的复用性和可维护性，当子类继承了父类，就自动的拥有父类的功能。
  - 接口的价值在于：设计，设计好各种规范（方法），让其它类去实现这些方法，即如果子类需要扩展功能，可以通过实现接口的方式扩展。这是对Java单继承机制的一种补充，使代码更加的灵活。
- 接口比继承更加灵活
  - 继承需要满足is-a关系，而接口只需满足like-a关系
- 接口在一定程度上实现代码解耦，即接口规范性 + 动态绑定机制

例子，

```java
interface A {
	int x = 0; // 等价 public static final int x = 0;
} 

class B {
	int x = 1; //普通属性
} 

class C extends B implements A {
    public void pX() {
    // System.out.println(x); //错误，原因不明确 x
    /* 解决方法：
    * 可以明确的指定 x，
    * 访问接口的 x 就使用 A.x，访问父类的 x 就使用 super.x
    */
    System.out.println(A.x + " " + super.x);
}
    
public static void main(String[] args) {
	new C().pX(); // 输出结果为0 1
}
```



-----

接口的多态特性：

- 接口类型的变量可以指向实现了该接口的类的对象实例，也可以转为实现该接口的类，类似向上转型和向下转型
- 多态参数，类似继承体现的多态，即接口引用可以指向实现了接口的类的对象实例
- 多态数组，类似继承体现的多态
- 接口存在多态传递现象，比如，若 IG 接口继承了 IH 接口，而 Teacher 类实现了 IG 接口，那么，实际上就相当于 Teacher 类也实现了 IH 接口



## 10.9 内部类

类的完整结构：

```java
package 包名;
class 类名 extends 父类 implements 接口名{
    1. 属性;
    2. 构造器;
    3. 方法;
    4. 代码块;
    5. 内部类;
}
```



基本介绍：

一个类的内部又完整地嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，桥套其他类的类称为外部类(outer class)。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

> 注意：内部类是学习的难点和重点，后面看底层源码时，有大量的内部类

---

基本语法：

```java
class Outer{ // 外部类
    class Inner{ // 内部类
    }
}

class Other{ // 外部其他类
}
```

内部类的分类：

- 定义在外部类局部位置上的（通常在方法内，也可以在代码块）

  - **局部内部类（有类名）**

    - 本质仍然是一个类
    - 可以直接访问外部类的所有成员，包含私有的
    - 不能添加访问修饰符，但是可以使用final修饰。因为它的地位就是一个局部变量，局部变量是不能使用修饰符的，但是可以使用final。
    - 作用域：仅仅在定义它的方法或代码块中
    - 局部内部类 ---访问---> 外部类成员（访问方式：直接访问）
    - 外部类 ---访问---> 局部内部类成员（访问方式：在局部内部类作用域中，创建局部内部类对象，再调用成员）
    - 外部其它类 ---不能访问---> 局部内部类（因为局部内部类地位是一个局部变量）
    - 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问（`外部类名.this`的本质就是外部类的对象，即哪个对象调用了局部内部类所在方法，`外部类名.this`就是哪个对象）

  - **匿名内部类（没有类名，重点！！！！！！）**

    - **本质仍然是一个类，同时还是一个对象。**匿名内部类其实是有类名的，是系统分配的，但是被系统隐藏起来了。 

    - 为什么需要匿名内部类？想使用接口，并创建对象，但是只使用一次，这样写一个类就显得比较繁琐，于是就使用匿名内部类来简化开发

    - 基本语法与底层代码
    
      ```java
      类或接口 对象名 = new 类或接口(参数列表){ // 括号不要忘记省略
          类体
      };
      
      // 底层代码，其中外部类$1的名称从1开始，按顺序编号
      class 外部类$1 extends/implements 类或接口(参数列表){
          类体
      };
      ```
    
      - 编译类型为类或接口，运行类型为匿名内部类
      - 参数列表会传递给构造器，而匿名内部类的类体不能声明构造器
      - 注意：jdk底层在创建匿名内部类 `外部类$1` 时，立即就创建了 `外部类$1` 实例，并且把地址返回给定义的对象
      - 匿名内部类使用一次，就不能再使用，但是返回地址的对象可以反复使用

    - 匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时也是一个对象，因此从语法上看，它既有定义类的特征，又有创建对象的特征，故可以调用匿名内部类方法有两种：

      - ```java
        类或接口 对象名 = new 类或接口(参数列表){
            类体
        };
        对象名.方法();
        ```
    
      - ```java
        对象名 = new 类或接口(参数列表){
            类体
        }.方法();
        ```
    
    - 可以直接访问外部类的所有成员，包含私有的
    
    - 不能直接添加访问修饰符，因为它的地位就是一个局部变量
    
    - 作用域：仅仅在定义它的方法或代码块中
    
    - 匿名内部类 ---访问---> 外部类成员（访问方式：直接访问）
    
    - 外部其他类 ---不能访问---> 匿名内部类（因为匿名内部类地位是一个局部变量）
    
    - 如果外部类和匿名内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问
    
    - 匿名内部类的最佳实践 ：当做实参直接传递，简洁高效。
    
      ```java
      public class InnerClassExercise01 {
      	public static void main(String[] arg){
              //当做实参直接传递，简洁高效
              f1(new IL() {
                  @Override
                  public void show() {
                      System.out.println("这是一副名画~~...");
                  }
              });
      		
              //静态方法,形参是接口类型
              public static void f1(IL il) {
                  il.show();
              }
          }
      
      //接口
      interface IL {
      	void show();
      }
      
      //传统方法：类->实现 IL => 编程领域 (硬编码)
      ```
    
      

- 定义在外部类成员位置上的（即属性或方法位置上）

  - **成员内部类（没有static修饰）**
    
    - 可以直接访问外部类的所有成员，包含私有的
    
    - 可以添加任意访问修饰符，因为它的地位就是一个成员
    
    - 作用域：和外部类的其他成员一样，为整个类体
    
    - 成员内部类 ---访问---> 外部类成员（访问方式：直接访问）
    
    - 外部类 ---访问---> 成员内部类（访问方式：创建成员内部类对象，再调用成员）
    
    - 外部其它类 ---访问---> 成员内部类，一共有三种访问方式
    
      - ```java
        // 把new 内部类名()当作外部对象名的一个成员
        外部类名 外部对象名 = new 外部类名();
        外部类名.内部类名 内部对象名 = 外部对象名.new 内部类名();
        ```
    
      - ```java
        // 定义一个返回内部类的方法
        public 内部类 方法名(){
            return new 内部类();
        }
        外部类名 外部对象名 = new 外部类名();
        外部类名.内部类名 内部对象名 = 外部对象名.方法名();
        ```
    
    - 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问
    
  - **静态内部类（使用static修饰）**
    
    - 可以直接访问外部类的所有成员，包含私有的，但不能直接访问非静态成员
    
    - 可以添加任意访问修饰符，因为它的地位就是一个成员
    
    - 作用域：和外部类其他成员一样，为整个类体
    
    - 静态内部类 ---访问---> 外部类成员（访问方式：直接访问）
    
    - 外部类 ---访问---> 静态内部类（访问方式：创建成员内部类对象，再调用成员）
    
    - 外部其它类 ---访问---> 静态内部类
    
      - ```java
        // 因为是静态的，所以可以直接通过 外部类名.内部类名 来调用（前提是满足访问权限）
        外部类名.内部类名 内部对象名 = new 外部类名.内部类名();
        ```
    
      - ```java
        // 定义一个返回内部类的方法
        public 内部类 方法名(){
            return new 内部类();
        }
        外部类名 外部对象名 = new 外部类名();
        外部类名.内部类名 内部对象名 = 外部对象名.方法名();
        ```
    
      - ```java
        // 定义一个返回内部类的静态方法
        public static 内部类 方法名(){
            return new 内部类();
        }
        外部类名.内部类名 内部对象名 = 外部类名.方法名();
        ```
    
    - 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员（该成员既可以为静态成员，也可以为非静态成员），则可以使用`外部类名.成员`去访问









