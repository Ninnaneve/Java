## 13.1 包装类 

包装类的分类：

1) 针对八种基本数据类型相应的引用类型—包装类 
2) 有了类的特点，就可以调用类中的方法

![image-20220709094224380](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220709094224380.png)

---

包装类和基本数据的转换：

- jdk5前的手动装箱和拆箱方式，装箱：基本类型 -> 包装类型，反之则是拆箱

```java
// 手动装箱
int n1 = 100;
Integer integer1 = new Integer(n1);
Integer integer2 = Integer.valueOf(n1);

//手动拆箱
int i = integer.intValue();
```

- jdk5及以后的自动装箱和拆箱方式

```java
//自动装箱
int n2 = 200;
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)

//自动拆箱
int n3 = integer2; 
```

- 自动装箱底层调用的是valueOf方法
- 其它包装类的用法类似



例题，下列语句输出结果？

```java
Object obj1 = true? new Integer(1): new Double(2.0);
```

结果为1.0，因为三元运算符是一个整体，会自动转型成精度最高的输出，因此为1.0而非1。但是if else就是分别计算的。

注意：这里的true是判断条件！

----

包装类型和 String 类型的相互转换：

```java
//包装类(Integer)->String
Integer i = 100; //自动装箱
String str1 = i + "";
String str2 = i.toString();
String str3 = String.valueOf(i); 

//String -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4); // 返回的是int，使用到自动装箱
Integer i3 = new Integer(str4); // 构造器，可以直接传入字符串
Integer i4 = Integer.valueOf(str4);
```

Integer 类和 Character 类的常用方法：

```java
System.out.println(Integer.MIN_VALUE); //返回最小值
System.out.println(Integer.MAX_VALUE);//返回最大值

System.out.println(Character.isDigit('a'));//判断是不是数字
System.out.println(Character.isLetter('a'));//判断是不是字母
System.out.println(Character.isUpperCase('a'));//判断是不是大写
System.out.println(Character.isLowerCase('a'));//判断是不是小写

System.out.println(Character.isWhitespace('a'));//判断是不是空格
System.out.println(Character.toUpperCase('a'));//转成大写
System.out.println(Character.toLowerCase('A'));//转成小写
```



经典面试题：下列语句输出结果？

```java
// 1
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j); //False

// 2、3
Integer m = 127; //底层 Integer.valueOf(127); -> 阅读源码，见下
Integer n = 127;//底层 Integer.valueOf(127);
System.out.println(m == n); //T


Integer x = 128;//底层 Integer.valueOf(128);
Integer y = 128;//底层 Integer.valueOf(128);
System.out.println(x == y);// F

/*
// 源码
public static Integer valueOf(int i) {
if (i >= IntegerCache.low && i <= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
}

解读:
1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回（这些数在类加载时就已经创建好了。类似Python中的缓存池：这些数字都有对应确定的缓存地址。引用时无需创建，直接引用即可）
2. 如果不在 -128~127，就直接 new Integer(i)
*/

// 4
Integer i9 = 127; // Integer.valueOf(127)
Integer i10 = new Integer(127);
System.out.println(i9 == i10);//F

// 一个是返回IntegerCache数组，一个是通过构造器构造Integer对象，肯定不是同一个

// 5、6
Integer i11 = 127;
int i12 = 127;
System.out.println(i11 == i12); //T

Integer i13 = 128;
int i14 = 128;
System.out.println(i13 == i14);//T

// 和基本数据类型进行比较时，包装类会调用方法（如intValue()）返回值，最终判断的是值是否相同
```



## 13.2 String 类 

String 类的理解和创建对象：

- String对象用于保存字符串也就是一组字符序列
- 字符串常量对象是用双括号引起的字符序列，如"Jess"
- 字符串的字符使用Unicode字符编码一个字符（不区分字母还是汉字）占两个字节
- String类有许多常用构造器（其它看手册），实现了类的重载：
  - String s1 = new String();
  - String s2 = new String(String original);
  - String s3 = new String(char[] a);
  - String s4 = new String(char[] a, int startIndex, int count);
  - String s5 = new String(byte[] b);
- String 类实现了接口 Serializable，使String 可以串行化，即可以保存到文件或者实现网络传输，还实现了接口 Comparable，使String 对象可以比较大小

![image-20220709105902697](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220709105902697.png)

- String 是 final 类，不能被其他的类继承
- String 本质还是一个char数组，String有属性 private final char value[]; 用于存放字符串内容
  - 一定要注意：value 是一个 final 类型， 不可以修改，这里修改指的是 value 不能指向新的地址，但是其指向的数组内容还是可以变化的

---

创建 String 对象的两种方式与区别：

- 方式一：直接赋值，如String s = "hsp";
  先从常量池中查看是否有“hsp”数据空间，如果有，则直接指向；如果没有，则重新创建，然后指向。s最终指向的是常量池的空间地址。
- 方式二：调用构造器，如String s = new String("hsp");
  先在堆中创建空间，里面维护了value属性（即上述的value[]），指向常量池的空间。如果常量池没有“hsp”，就重新创建，如果有，直接通过value指向，最终指向的是堆中的空间地址。

![2022-07-09_11-29-05](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/2022-07-09_11-29-05.jpg)



P.S. String.intern()：返回常量池的地址。若常量池存在相同字符串（用equals方法确定），则返回常量值对应地址；若不存在，则将此对象添加到常量池中，并返回对象的引用地址

```java
String a = "hsp";
String b = new String("hsp");
sout(a == b.intern()); // T
sout(b == b.intern()); // F

Person p1 = new Person();
p1.name = "hsp";
sout(p1.name == "hsp"); // T，因为"hsp"不是new出来的，底层就是常量池中对应字符串的地址
```



## 13.3 字符串的特性
- 字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。
  - 因为value是private的，并且没有提供setValue等公共方法来修改这些值，所以在String类的外部无法修改String。也就是说一旦初始化就不能修改， 并且在String类的外部不能访问这个成员。
  - 此外，value这个变量是final的， 也就是说在String类内部，一旦值初始化了， 就不能被改变。所以可以认为String对象是不可变的了。
  - 但是注意，value属性是引用类型，final修饰后不能再指向其它对象，但可以改变value指向的数组元素。一般情况下，由于private的限制无法更改，但可以通过反射来更改，不过不推荐使用。（暂时超纲了）

> 在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。
>
> ——参考文章：https://blog.csdn.net/zhangjg_blog/article/details/18319521



面试题：以下语句创建了几个对象？

```java
String s1 = "hello";
s1 = "ciao";
```

2个。这里是因为忘记直接赋值就直接指向常量池了。

```java
String a = "hello" + "abc";
```

1个。编译器会自己做优化，会判断创建的常量池对象是否有引用指向。

```java
String a = "hello";
String b = "abc";
String c = a + b;
```

3个。

关键是分析String c = a + b;到底是如何执行的：

1. 创建一个StringBuilder sb = new StringBuilder();
2. 执行sb.append(a);
3. 执行sb.append(b);（append是在原来字符串的基础上追加的）
4. 得到String c = sb.toString();，最后其实是c指向堆中的对象(String) value[]，其指向池中的"helloabc"

> 规则：全常量相加看池，有变量相加在堆。（有变量即只要有一个变量）
>
> 学习思想：一定尽量看源码学习。



面试题2：下列程序的运行结果是什么？

```java 
class Test1 {
    String str = new String("hsp");
    final char[] ch = {'j', 'a', 'v', 'a'};

    public void change(String str, char ch[]) {
        str = "java";
        ch[0] = 'h';
    }

    public static void main(String[] args) {
        Test1 ex = new Test1();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.println(ex.ch);
    }
}
```

自己的主要错误点：

1. 对象str在堆中指向String中的value[]属性，然后再由value[]属性指向常量池；
2. 对象ch在堆中指向给数组存放值的一块空间；
3. 在main方法调用方法会开辟一个新栈；
4. 方法传入ex.str, ex.ch时，属于局部变量，与Test对象属性无关，指向的仍是上述空间；
5. str = "java";直接断开了原有连接，而去指向常量池，相当于字符串的直接赋值；
6. 最后ex.str仍然指向原有的value[]属性。

![2022-07-09_14-09-11](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/2022-07-09_14-09-11.jpg)



## 13.4 String类常见方法
String类是保存字符串常量的，每次更新都需要开辟新空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能并提高效率。

String 类的常见方法（只知道怎么用即可）：

- equals：比较内容是否相同，区分大小写

- equalsIgnoreCase：忽略大小写的判断内容是否相等

- length：获取字符的个数，字符串的长度

- indexOf：获取字符/字符串在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1

- lastIndexOf：获取字符/字符串在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1

- substring：截取指定范围的子串，左闭右开。

  >  如a.substring(6)表示从索引6开始截取后面所有的内容；a.substring(0,5)表示从索引0开始截取，截取到第5个字符，

- trim：去前后空格

- charAt：获取某索引处的字符。

  > 注意：获取索引不能使用Str[index]这种方式，String不能用数组的取法！

- toUpperCase：转换成大写

- toLowerCase：转换成小写

- concat：拼接字符串。

  > concat与+的区别：
  >
  > - concat：使用Arrays对字符串进行拼接，并返回一个新String对象，原有对象保留
  >
  > ```java
  > public String concat(String str) {
  >     if (str.isEmpty()) {
  >         return this;
  >     }
  >     int len = value.length;
  >     int otherLen = str.length();
  >     char buf[] = Arrays.copyOf(value, len + otherLen);
  >     str.getChars(buf, len);
  >     return new String(buf, true);
  > }
  > ```
  >
  > - +：对于常量，直接拼接成一个新对象，原有对象丢弃；对于变量，使用StringBuilder sb = new StringBuilder();，sb.append(a);，sb.append(b);，String c = sb.toString();返回一个新String对象，原有对象保留

- replace：替换字符串中的所有字符

  > 注意：替换对原字符没有任何影响，因为源码没有return一个新的String对象，从而把原有对象引用替换了
  >
  > ```java
  > public String replace(CharSequence target, CharSequence replacement) {
  >     return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(
  >         this).replaceAll(Matcher.quoteReplacement(replacement.toString()));
  > }
  > ```
  >
  > 

- split：分割字符串，对于某些分割字符，我们需要加入转义符

- toCharArray：转换成字符

- compareTo：比较两个字符串的大小。

  - 如果长度相同，并且每个字符也相同，就返回 0
  - 如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回 if (c1 != c2) { return c1 - c2; } 
  - 如果前面的部分都相同，但是长度不同，就返回 str1.len - str2.len

- format：格式字符串

  - %s , %d , %.2f, %c 称为占位符，这些占位符由后面变量来替换
    - %s 表示由字符串来替换 
    - %d 表示由整数来替换
    - %.2f 表示由小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 
    - %c 使用 char

  ```java
  String name = "john";
  int age = 10;
  double score = 56.857;
  char gender = '男';
  String formatStr = "我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！";
  String info2 = String.format(formatStr, name, age, score, gender);
  ```

  

## 13.5 StringBuffer 类

基本介绍：

- java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删，其很多方法与String相同，但StringBuffer是**可变长度**的。

- StringBuffer是一个容器。
- StringBuffer 的直接父类 是 AbstractStringBuilder 
- StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 
- 在父类中 AbstractStringBuilder 有属性 char[] value，注意不是 final类型的。该 value 数组存放字符串内容，因此是存放在堆中的，而不是再常量池中。
- StringBuffer 是一个 final 类，不能被继承
- 因为 StringBuffer 字符内容是存在 char[] value中的, 所有在变化(增加/删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String。

----

String VS StringBuffer：

- String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址（即在常量池新增一个地址），效率较低 // private final char value[];

- StringBuffer保存是的字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高 // char[] value;

  > 只有在StringBuffer内存不够的时候才会更新地址

---

StringBuffer 类构造器：

- StringBuffer()：构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。
- StringBuffer(CharSequence seq)：public java.lang.StringBuilder(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的  CharSequence 相同的字符。
- StringBuffer(int capacity)：构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定。
- StringBuffer(String str)：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容，char[] 的大小就是str.len + 16。

----

StringBuffer 和 String 的相互转换：

- String——>StringBuffer

  - 方式1 使用构造器

    ```java
    String str = "hello tom";
    StringBuffer stringBuffer = new StringBuffer(str);
    ```

    > 注意： 返回的才是StringBuffer对象，对str 本身没有影响

  - 方式2 使用append方法

    ```java
    StringBuffer stringBuffer1 = new StringBuffer();
    stringBuffer1 = stringBuffer1.append(str);
    ```

- StringBuffer ->String

  - 方式1 使用StringBuffer提供的 toString方法

  ```java
  StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");
  String s = stringBuffer3.toString();
  ```

  - 方式2 使用构造器

  ```java
  String s1 = new String(stringBuffer3);
  ```

---

StringBuffer类常见方法：

- 增 append(string)

  ```java
  StringBuffer s = new StringBuffer("hello")
  s.append("赵敏").append(100).append(true).append(10.5);
  System.out.println(s); // 输出的是一个对象（参考源码）
  ```

- 删 delete(start, end)，左闭右开

- 改 replace(start, end, string)，左闭右开，替换字符串可以和原有长度不等

- 查 indexOf(place)，查找指定的子串在字符串第一次出现的索引，如果找不到返回-1

- 插 insert(place, string)，在指定位置插入字符串，原来相应位置后的内容自动后移

- 获取长度 length(string)



例题，

```java
String str = null;// ok
StringBuffer sb = new StringBuffer(); //ok
sb.append(str);//需要看源码, 底层调用的是 AbstractStringBuilder 的 appendNull，会增加n, u, l, l四个字符 
System.out.println(sb.length());//4

System.out.println(sb);//null
//下面的构造器，会抛出NullpointerException
StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);
System.out.println(sb1);
```



P.S. 练习2（输入价格，格式化为千位制）对String和StringBuffer方法的巧妙使用值得反复思考。



## 13.6 StringBuilder 类 

基本介绍：

- 一个可变的字符序列。此类提供一个与String Buffer兼容的API，但不保证同步（StringBuilder不是线程安全的）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区**被单个线程使用**的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。
- 在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。

- StringBuilder 和 StringBuffer 均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。（参考StringBuffer基本介绍）
- StringBuilder 的方法，没有做互斥的处理，即没有synchronized关键字，因此推荐在单线程情况下使用

----

String、StringBuffer 和 StringBuilder 的比较：

- StringBuffer 和 StringBuilder 非常类似，均代表可变的字符串序列，而且方法也一样
- String：不可变字符序列，效率低，但是复用率高
- StringBuffer：可变字符序列，效率较高（增删）、线程安全
- StringBuilder：可变字符序列，效率最高、线程不安全
- String使用注意说明：若我们对String要做大量修改，则不要使用String

----

String、StringBuffer 和 StringBuilder 的选择：

- 如果字符存在大量修改操作
  - 一般使用StringBuffer或StringBuilder
  - 单线程使用StringBuilder
  - 多线程使用StringBuffer
- 若干字符串很少修改，被多个对象引用，使用String，比如配置信息等



## 13.7 Math 类

基本介绍：Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

方法一览(均为静态方法)：

- abs

- pow 求幂

- ceil 向上取整，返回>=该参数的最小整数

- floor 向下取整，返回<=该参数的最大整数

- round 四舍五入

- sqrt

- random 获取随机数，返回的是 0 <= x < 1 之间的一个随机小数

  > 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b = 7
  >
  > A：(int)(a) <= x <= (int)(a + Math.random() * (b-a +1) )
  >
  > 注意：int是只保留整数部分，因此需要加一

- max

- min



## 13.8 Arrays 类

Arrays 里面包含了一系列静态方法，用于管理或操作数组（如排序或搜索）。

Arrays 类常见方法：

- toString：返回数组的字符串形式

  ```java
  //直接使用 Arrays.toString 方法，显示数组
  Integer arr[] = {1, -1, 7, 0, 8};
  System.out.println(Arrays.toString(integers)); // [1, -1, 7, 0, 8]
  ```

- sort：排序（分为自然排序和定制排序）

  - 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr（个人认为和源码也有关系）

  - sort 也可以通过重载传入一个接口 Comparator 实现定制排序。调用定制排序 时，传入两个参数： (1) 排序的数组 arr； (2) 实现了 **Comparator 接口**的匿名内部类，要求实现 compare 方法。

    ```java
    Arrays.sort(arr, new Comparator() { // 匿名内部类
        @Override
        public int compare(Object o1, Object o2) {
            Integer i1 = (Integer) o1;
            Integer i2 = (Integer) o2;
            return i2 - i1;
        }
    });
    ```

    - 这里体现了接口编程的方式 , 看看源码就明白了。

      ```java
      /*
      源码分析：
      1. Arrays.sort(arr, new Comparator()...，
      最终到 TimSort 类的 private static <T> void binarySort(T[] a, int lo, int hi, int start, Comparator<? super T> c)()
      2. 执行到的 binarySort 方法的代码, 会根据动态绑定机制 c.compare() 执行我们传入的匿名内部类的 compare ()。
      3. public int compare(Object o1, Object o2) 返回的值 >0 还是 <0 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类 的综合使用。将来的底层框架和源码的使用方式，会非常常见。
      */
      
      // 源码
      while (left < right) {
          int mid = (left + right) >>> 1;
          if (c.compare(pivot, a[mid]) < 0)
          	right = mid;
          else
          	left = mid + 1;
      }
      
      // 自己重写的compare方法 
      new Comparator() {
          @Override
          public int compare(Object o1, Object o2) {
              Integer i1 = (Integer) o1;
              Integer i2 = (Integer) o2;
              return i2 - i1;
          }
      }
      ```

  - 冒泡 + 定制排序实例

    ```java
    int[] arr = {1, -1, 8, 0, 20};
    
    bubble02(arr, new Comparator() {
        @Override
        public int compare(Object o1, Object o2) {
            int i1 = (Integer) o1;
            int i2 = (Integer) o2;
            return i2 - i1; // return i2 - i1;
        }
    });
    
    public static void bubble02(int[] arr, Comparator c) {
        int temp = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                //数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定
                if (c.compare(arr[j], arr[j + 1]) > 0) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    ```

    

- binarySearch：通过二分搜索法进行查找，**要求必须排好序**

  ```java
  Integer[] arr = {1, 2, 90, 123, 567};
  int index = Arrays.binarySearch(arr, 567);
  ```

  - 如果数组中不存在该元素，就返回 return -(low + 1);，low表示该数应该存在的位置。

- copyOf：数组元素的复制

  ```java
  // 表示从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中
  Integer[] newArr = Arrays.copyOf(arr, arr.length);
  ```

  - 如果拷贝的长度 > arr.length ，就在新数组的后面增加 null
  - 如果拷贝长度 < 0 ，就抛出异常 NegativeArraySizeException 
  - 该方法的底层使用的是 System.arraycopy()

- fill：数组元素的填充

  ```java
  // 使用 99 去填充 num 数组，可以理解成是替换原来所有的元素
  Arrays.fill(num, 99);
  ```

- equals：比较两个数组元素内容是否完全一致

  ```java
  // 如果 arr 和 arr2 数组的元素一样，则方法 true; 如果不是完全一样，就返回 false
  boolean equals = Arrays.equals(arr, arr2);
  ```

- asList：将一组值转换成list

  ```java
  /* 
  解读：
  1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合
  2. 返回的 asList 编译类型为 List(接口)
  3. asList 运行类型 java.util.Arrays$ArrayList, 是 Arrays 类的静态内部类。private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java.io.Serializable
  */
  List asList = Arrays.asList(2,3,4,5,6,1);
  ```

  



## 13.9 System 类

1 System 类常见方法：

- exit：退出当前程序

  ```JAVA
  System.exit(0); // 0 表示正常退出的状态
  ```

- arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组（其底层即为arraycopy）

  ```java
  int[] src={1,2,3};
  int[] dest = new int[3];// dest 当前是 {0,0,0}
  System.arraycopy(src, 0, dest, 0, src.length);
  
  /*
  主要是搞清楚这五个参数的含义：
  1. 源数组
  * @param src the source array.
  2. srcPos： 从源数组的哪个索引位置开始拷贝
  * @param srcPos starting position in the source array. 
  3. dest : 目标数组，即把源数组的数据拷贝到哪个数组
  * @param dest the destination array. 
  4. destPos: 把源数组的数据拷贝到目标数组的哪个索引
  * @param destPos starting position in the destination data. 
  5. length: 从源数组拷贝多少个数据到目标数组
  * @param length the number of array elements to be copied. System.arraycopy(src, 0, dest, 0, src.length)
  */
  ```

- currentTimeMillens：返回当前时间距离1970-1-1的毫秒数

  ```java
  System.out.println(System.currentTimeMillis());
  ```

- gc：运行垃圾回收机制System.gc()（见前finalize章节）



## 13.10 BigInteger 和 BigDecimal 类

应用场景：

- 当我们需要处理很大的整数时，long 不够用，可以使用 BigInteger 的类来搞定

  ```java
  BigInteger bigInteger = new BigInteger("23788888899999999999999999999");
  BigInteger bigInteger2 = new BigInteger("10099999999999999999999999999999999999999999999999999999999999999999999999999999999");
  BigInteger add = bigInteger.add(bigInteger2); // 下同（包括BigDecimal），不演示了
  ```

  - 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /

- 当我们需要保存一个精度很高的数时，double 不够用，可以使用 BigDecimal 的类来搞定

  ```java
  BigDecimal bigDecimal = new BigDecimal("1999.11111111111999999999999977788");
  BigDecimal bigDecimal2 = new BigDecimal("3");
  System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));
  ```

  - 在对 BigDecimal 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
  - 在调用 divide 方法时，可能抛出异常ArithmeticException（出现无限循环小数时）。解决方法：用BigDecimal.ROUND_CEILING指定精度，会保留 **分子 的精度**。



BigInteger 和 BigDecimal 常见方法：

- add 加
- substract 减
- multiply 乘
- divide 除



## 13.11日期类

### 13.11.1 第一代日期

Date：精确到毫秒，代表特定的瞬间

- 用于获取当前系统时间 
- 这里的 Date 类是在 java.util 包中
- 默认输出的日期格式是国外的方式，因此通常需要对格式进行转换，使用SimpleDateFormat类即可

```java
//获取当前系统时间
Date d1 = new Date(); 
System.out.println("当前日期=" + d1);

//通过指定毫秒数得到时间
Date d2 = new Date(9234567); 
System.out.println("d2=" + d2); //获取某个时间对应的毫秒数

//把一个格式化的 String 转成对应的 Date
String s = "1996 年 01 月 01 日 10:20:30 星期一";
Date parse = sdf.parse(s); 
// 在把 String -> Date 时， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常ParseException
System.out.println("parse=" + sdf.format(parse));
// 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换
```



SimpleDateFormat：格式和解析日期的具体类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。

- 创建 SimpleDateFormat 对象，可以指定相应的格式
- 这里的格式使用的字母是规定好，不能乱写

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy 年 MM 月 dd 日 hh:mm:ss E");
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
```

![image-20220710204656717](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220710204656717.png)



> 补充：IDEA diagram中的properties是get和set方法，不是属性！



### 13.11.2 第二代日期类

- 第二代日期类，主要就是Calendar类（日历），其提供大量的方法和字段提供给程序员。它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供令一些方法。
- Calendar类是在 java.util 包中
- Calendar类是一个抽象类，并且构造器是 private的，一般通过 getInstance()来获取实例（类似通过设计模式解决的）

```java
Calendar c = Calendar.getInstance(); //创建日历类对象(比较简单，自由)
```

- Calendar类包含诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等属性
- Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)

```java
System.out.println("年：" + c.get(Calendar.YEAR));
// 这里为什么要 + 1？因为 Calendar 返回月时候，是按照 0 开始编号
System.out.println("月：" + (c.get(Calendar.MONTH) + 1));
System.out.println("日：" + c.get(Calendar.DAY_OF_MONTH));
System.out.println("小时：" + c.get(Calendar.HOUR));
System.out.println("分钟：" + c.get(Calendar.MINUTE));
System.out.println("秒：" + c.get(Calendar.SECOND));
```

- 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR 改成Calendar.HOUR_OF_DAY即可



### 13.11.3 第三代日期类

前面两代日期类的不足分析：

- JDK1.0就包含了java.util.Date类，但它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。
- 对于Calendar类，也存在如下问题：
  - 可变性：像日期和时间这样的类应该是不可变的
  - 偏移类：Date中的年份是从1900开始的，而月份都从0开始
  - 格式化：格式化只对Date有用，Calendar则不行
  - 不是线程安全的
  - 不能处理闰秒（每隔两天，多出1秒）

---

JDK8加入了LocalDate（日期/年月日）、LocalTime（时间/时分秒）、LocalDateTime（日期时间/年月日时分秒）。

以LocalDateTime为例，展示常用方法：

- 使用 now() 返回表示当前日期时间的对象

```java
LocalDateTime ldt = LocalDateTime.now();

System.out.println("年=" + ldt.getYear());
System.out.println("月=" + ldt.getMonth()); // 获取英文月份
System.out.println("月=" + ldt.getMonthValue()); // 获取月份数字
System.out.println("日=" + ldt.getDayOfMonth());
System.out.println("时=" + ldt.getHour());
System.out.println("分=" + ldt.getMinute());
System.out.println("秒=" + ldt.getSecond());
LocalDate now = LocalDate.now(); //可以获取年月日
LocalTime now2 = LocalTime.now(); //获取到时分秒
```

- DateTimeFormatter 格式日期类

  类似SimpleDateFormat，对日期进行格式化。这里的格式参考相应API文档。

```java
// 创建 DateTimeFormatter 对象
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String format = dateTimeFormatter.format(ldt);
System.out.println("格式化的日期=" + format);
```

- Instant 时间戳

  类似于Date，提供了一系列和Date类转换的方式。

```java
//1. 通过 静态方法 now() 获取表示当前时间戳对象
Instant now = Instant.now();
System.out.println(now);
//2. 通过 from 可以把 Instant 转成 Date
Date date = Date.from(now);
//3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象
Instant instant = date.toInstant();
```

* MonthDay类：检查重复事件

* 是否是闰年

* 增加日期的某个部分

* 使用plus方法测试增加时间的某个部分

* 使用minus方法测试查看一年前和一年后的日期

  ```java
  //plus 和 minus方法可以对当前时间进行加或者减
  //1. 看看 890 天后，是什么时候，把 年月日-时分秒 输出
  LocalDateTime localDateTime = ldt.plusDays(890);
  System.out.println("890 天后=" + dateTimeFormatter.format(localDateTime));
  
  //2. 看看在 3456 分钟前是什么时候，把 年月日-时分秒 输出
  LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
  System.out.println("3456 分钟前 日期=" + dateTimeFormatter.format(localDateTime2));
  ```

* 其他方法看API吧
