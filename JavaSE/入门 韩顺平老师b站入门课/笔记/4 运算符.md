## 4.1 运算符介绍

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 

1) 算术运算符 
2) 赋值运算符
3) 关系运算符 [比较运算符]
4) 逻辑运算符
5) 位运算符 [需要二进制基础]
6) 三元运算符

## 4.2 算数运算符

算术运算符是对数值类型的变量进行运算。

![image-20220613100536502](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613100536502.png)

注意事项：

- /整数除和小数除是有区别的。整数相除，只会保留整数位，若整数除转为浮点数，只会在加.0，不会变成正确的数学运算结果
- %余数本质看一个公式：a % b = a - (int)a / b * b，其中(int)仅针对a为小数的情况
- 自增：++
  - 作为独立语句使用：前++和后++都完全等价于i = i + 1;
  - 作为表达式使用
    - 前++：++i先自增后赋值（int k = ++j; // j = j + 1; k = j;）
    - 后++：i++先赋值后自增（int k = j++; // k = j; j = j + 1;）

> 面试题
>
> 1. int i = 1; i = i++; i?
>
> 解：temp = i; i = i + 1; i = temp;
>
> 2. int i = 1; i = ++i; i?
>
> 解：i = i + 1; temp = i; i = temp;

-----------------------

P.S. 写代码三部曲

1. 理解需求
2. 思路分析

> 容易替换的值尽量单独保存为一个变量，如需要计算的天数

3. 写代码

> 开发中，不可以使用单字母简单命名，如a, b, a1, b2...

## 4.3 关系运算符(比较运算符)

细节说明：

- 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false
- 关系运算符组成的表达式，我们称为关系表达式，如a>b。关系表达式经常用在 if 结构的条件中或循环结构的条件中
- 比较运算符"=="不能误写成"="

![image-20220613111831998](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613111831998.png) 

> 注意：在进行比较时，只有char才可以用==，因为char本质是数字比较；String要用equals方法，例如"丁真".equals(userName) /userName.equals("丁真")，表示比较userName是否等于"丁真"，使用时推荐例子中的第一种表达方法，因为能避免空指针的问题

## 4.4 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。

分类：

- 短路与 && ， 短路或 ||，取反 !
- 逻辑与 &，逻辑或 |，^ 逻辑异或

![image-20220613112523073](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613112523073.png)

逻辑运算规则：

- a&b : & 叫逻辑与。规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false
- a&&b : && 叫短路与。规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 
- a|b : | 叫逻辑或。规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 
- a||b : || 叫短路或。规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 
- !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 
- a^b: 叫逻辑异或。规则：当 a 和 b 不同时，则结果为 true, 否则为 false

-----------------------

&& 和 & 的区别：

- 对于&&短路与而言，如果第一个条件为 false，后面的条件不再判断，最终结果为false，效率高
- 对于&逻辑与而言，如果第一个条件为 false，后面的条件仍然会判断，效率低
- 开发中，使用的基本是短路与&&

--------------------

|| 和 | 使用区别:

- ||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高 
- | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低 
- 开发中，我们基本使用 ||

## 4.5 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

分类：

- 基本赋值运算符 =，如int a = 10;
- 复合赋值运算符+= ，-= ，*= ， /= ，%= 等，如a += b;等价于 a = a + b;

---

特点：

- 运算顺序从右往左，即先计算等号右边的值，再将等号右边的值赋给左边
- 赋值运算符的左边只能是变量，右边 可以是变量、表达式、常量值
- 复合赋值运算符**会进行类型转换**。 

> ```java
> byte b = 2; 
> b += 3; // 等价于b = (byte)(b + 3); 但是直接写b = b + 3;就会报错
> b++; // 等价于b = (byte)(b + 1)
> ```



## 4.6 三元运算符

基本语法——条件表达式 ? 表达式 1: 表达式 2; 

运算规则： 

1. 如果条件表达式为 true，运算后的结果是表达式 1
2. 如果条件表达式为 false，运算后的结果是表达式 2

----

使用细节：

- 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)
- 三元运算符可以转成 if--else 语句



P.S. 在分析赋值时，多使用**内存分析法**



 ## 4.7 运算符优先级

运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。

只有单目运算符、赋值运算符是从右向左运算的，即表中R—>L的两行。

![image-20220613144403027](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613144403027.png)

大致分类：

1. (), {}等
2. 单目运算
3. 算数运算符
4. 位移运算符
5. 比较运算符
6. 逻辑运算符
7. 三元运算符
8. 赋值运算符



## 4.8 标识符的命名规则和规范

标识符概念：

Java对各种变量、方法和类等命名时使用的字符序列称为标识符，即凡是自己可以起名的地方都叫标识符

规则（必须遵守）：

- 由26个英文字母大小写，0-9，_或$组成
- 数字不可以开头
- 不可以使用关键字和保留字，但可以包含关键字和保留字
- Java严格区分大小写。长度无限制
- 标识符不能包含空格

------------

规范（更加专业）：

- **包名**：多单词组成时所有字母**都小写**：aaa.bbb.ccc ，如 com.hsp.crm 
- **类名、接口名**：多单词组成时，**所有单词的首字母大写**[大驼峰]：XxxYyyZzz ，如TankShotGame 
- **变量名、方法名**：多单词组成时，**第一个单词首字母小写，第二个单词开始每个单词首字母大写**[小驼峰]：xxxYyyZzz ，如 tankShotGame 
- **常量名**：**所有字母都大写**。多单词时**每个单词用下划线连接**：XXX_YYY_ZZZ ，如定义一个所得税率 TAX_RATE 



## 4.9 关键字

被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 

特点：关键字中所有字母都为**小写**

![image-20220613150231155](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613150231155.png)

![image-20220613150352503](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613150352503.png)



## 4.10 保留字

现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。

自己命名标识符时要避免使用这些保留字： byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const



## 4.11 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个**扫描器(对象)**，就是 Scanner

步骤：

1. 导入该类的所在包, java.util.* 

> 例如，
>
> ```java
> import java.util.Scanner; // Scanner类表示简单文本扫描器
> ```

2. 创建该类对象（声明变量）

> 例如，
>
> ```java
> Scanner myScanner = new Scanner(System.in);
> ```

3. 调用里面的功能

> 例如，
>
> ```java
> System.out.println("请输入名字");
> String name = myScanner.next();
> System.out.println("请输入年龄");
> int age = myScanner.nextInt();
> System.out.println("请输入薪水");
> double salary = myScanner.nextDouble();
> ```



## 4.12 进制

对于整数，有四种表示方式： 

- 二进制：0,1 ，满 2 进 1。以 0b 或 0B 开头。 
- 十进制：0-9 ，满 10 进 1。 
- 八进制：0-7 ，满 8 进 1。以数字 0 开头表示。 
- 十六进制：0-9 及 A(10)-F(15)，满 16 进 1。以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。

![image-20220613153200428](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613153200428.png)

![image-20220613153211484](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613153211484.png)



## 4.14 进制的转换（基本功）

第一组： 

> 在println输出时，无论什么样是进制，均默认转为十进制

1) 二进制转十进制 

规则：从最低位(右边)开始，将每个位上的数提取出来，乘以2的(位数-1)次方，然后求和。

> 例如，
>
> ob1010 = 1\*2的(1-1)次方 + 1\*2的(2-1)次方 + 0\*2的(3-1)次方 + 1\*2的(4-1)次方 = 1 + 2 + 0 + 8 = 11

2. 八进制转十进制 

规则：从最低位(右边)开始，将每个位上的数提取出来，乘以8的(位数-1)次方，然后求和。

> 例如，
>
> 0234 = 4\*8^0 + 3\*8^1 + 2\*8^2 + 0\*8^3 = 4 + 24 + 128 = 156

3. 十六进制转十进制

规则：从最低位(右边)开始，将每个位上的数提取出来，乘以16的(位数-1)次方，然后求和。

> 例如，
>
> ox23A = 10\*16^0 + 3\*16^1 + 2\*16^2 = 10 + 48 + 512 = 570

------------

第二组：

1) 十进制转二进制 

规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的**余数**倒过来，就是对应的二进制。

> 例如，请将 34 转成二进制 = 0B00100010
>
> 注意：一个字节有8位，因此前面还需要补两个0
>
> ![image-20220613162645938](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220613162645938.png)

2. 十进制转八进制

规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。

> 例如，将 131 转成八进制 => 0203（原理同上）

3. 十进制转十六进制

规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。

> 例如，将 237 转成十六进制 => 0xED（原理同上）

--------

第三组：

1) 二进制转八进制 

规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。

> 例如，将 ob11010101 转成八进制
>
> ob11(3)010(2)101(5) => 0325

2. 二进制转十六进制

规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。

> 例如，将 ob11010101 转成十六进制
>
> ob1101(D)0101(5) = 0xD5

第四组：

1) 八进制转二进制

规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即

> 例如，请将 0237 转成二进制 
>
> 02(010)3(011)7(111) = 0b10011111

2. 十六进制转二进制

规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制

> 例如，请将 0x23B 转成二进制 
>
> 0x2(0010)3(0011)B(1011) = 0b001000111011

P.S. 具体例题请看笔记

## 4.26 二进制在运算中的说明

二进制是逢2进位的进位制，0、1是基本算符。

二进制数用0和1两个数字及其组合来表示任何数。进位规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。

## 4.27 原码、反码、补码 (重点难点)

网上对原码, 反码, 补码的解释过于复杂, 这里精简几句话：

对于有符号的而言:

1. 二进制的最高位是符号位: 0表示正数, 1表示负数(口决: 0->0 1->-)

2. 正数的原码, 反码, 补码都一样(三码合一)

3. 负数的反码=它的原码符号位不变, 其它位取反(0->1, 1->0)

4. 负数的补码=它的反码+1,负数的反码=负数的补码-1

5. 0的反码，补码都是0（只针对0这个值，而不是二进制中的数字0）
6. java没有无符号数，换言之，java中的数都是有符号的

7. 在计算机运算的时候, 都是以**补码的方式**来运算的

8. 当我们看运算结果的时候, 要看他的**原码**(重点)

## 4.28 位运算符

7个位运算符：

- 按位与&：两位全为1，结果为1，否则为0

> 例如，2&3=?
>
> 1. 2的补码 => 2的原码 00000000 00000000 00000000 00000010，
>    则2的补码 00000000 00000000 00000000 00000010（正数三码合一）
> 2. 3的补码 3的原码 00000000 00000000 00000000 00000011，
>    则3的补码 00000000 00000000 00000000 00000011
> 3. 按位&
>    00000000 00000000 00000000 00000010
>    00000000 00000000 00000000 00000011 
>    00000000 00000000 00000000 00000010 为运算后的补码
>    运算后的原码 也是  00000000 00000000 00000000 00000010
>    结果就是  2

- 按位或|：两位有一个为1，结果为1，否则为0，比如2|3=?
- 按位异或^：两位有一个为0，一个为1，结果为1，否则为0，比如-3^3=?
- 按位取反~：0->1, 1->0

> 例如，
>
> ~-2=?
>
> 1. 先得到-2的原码 10000000 00000000 00000000 00000010
>
> 2. 负数要得到补码，需要先通过原码得到反码
>
>    -2的 反码 	       11111111 11111111 11111111 11111101
>
> 3. 再得到-2的补码  11111111 11111111 11111111 11111110
>
> 4. ~-2操作               00000000 00000000 00000000 00000001 为运算后的补码
>
> 5. 运算后的原码 就是 00000000 00000000 00000000 00000001 => 1
>
> ~2=?
>
> 1. 得到2的补码 00000000 00000000 00000000 00000010
>
> 2. ~2操作          11111111 11111111 11111111 11111101  为运算后的补码，是负数，需要通过转为反码得到原码
>
> 3. 运算后的反码  11111111 11111111 11111111 11111100
>
> 4. 运算后的原码  10000000 00000000 00000000 00000011=>-3

3个位运算符：

- 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位 

> 本质上是1 / 2 / 2
>
> 例如，1 >> 2：00000001 -> 00000000

- 算术左移 <<: 符号位不变,低位补 0

> 本质上是1 * 2 * 2
>
> 例如，1 << 2：00000001 -> 00000100

- \>\>\> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 

- 特别说明：没有 <<< 符

P.S. 具体例题请看笔记