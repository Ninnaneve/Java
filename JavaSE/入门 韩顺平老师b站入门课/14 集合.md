## 14.1 集合的理解和好处

数组：

- 长度在初始化时必须指定，而且一旦指定，不能更改
- 保存的必须为同一类型元素
- 使用数组进行增删元素时，比较麻烦

集合：

- 可以动态保存任意多个对象，使用比较方便
- 提供了一系列方便操作对象的方法：add、remove、get、set等
- 使用集合添加、删除新元素，简洁明了



## 14.2 集合的框架体系 

Java 的集合类很多，主要分为两大类，如图（背下来） ：

![image-20220711164312425](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220711164312425.png)

- 集合主要是两组：单列集合 , 双列集合)。
  - 单列集合放单个元素，如Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合
  - 双列集合存放的 K-V（键值对）类型数据，如Map 接口的实现子类是双列集合。



## 14.3 Collection 接口和常用方法

Collection 接口实现类的特点：

> ```java
> public interface Collection<E> extends Iterable<E>
> ```

- Collection 实现子类可以存放多个元素，每个元素可以是Object
- 有些Collection 的实现类，可以存放重复的元素，有些不可以
- 有些Collection 的实现类，有些是有序的(List)，有些不可以(Set)
- Collection 接口没有直接的实现子类（因为接口不能被直接实例化），是通过它的子接口Set和List来实现的

Collection 接口常用方法（以实现子类 ArrayList 来演示）：

- 创建ArrayList：`List list = new ArrayList();`

- add:添加单个元素

  ```java
  list.add("jack");
  list.add(10);//list.add(new Integer(10))
  list.add(true);
  ```

- remove:删除指定元素

  ```java
  list.remove(0);//删除第一个元素
  list.remove(true);//指定删除某个元素
  ```

- contains:查找元素是否存在 ，返回boolean `list.contains("jack")`

- size:获取元素个数 `list.size()`

- isEmpty:判断是否为空 `list.isEmpty()`

- clear:清空，返回[] `list.clear()` 

- addAll:添加多个元素

  ```java
  ArrayList list2 = new ArrayList();
  list2.add("红楼梦");
  list2.add("三国演义");
  list.addAll(list2);
  ```

- containsAll:查找多个元素是否都存在，返回boolean `(list.containsAll(list2)`

- removeAll：删除多个元素 `list.removeAll(list2)`

---

Collection 接口遍历元素方式 

1. 使用 Iterator(迭代器)

   -  Iterator对象用于遍历Collection集合中的所有元素

   - 所有实现Collection接口的子类都有一个iterator()方法，用以返回一个实现Iterator接口的对象，即可以返回一个迭代器

   -  Iterator仅用于遍历**集合**， Iterator本身并不存放对象

   - 迭代器的执行原理

     ```java
     Iterator iterator = coll.iterator(); // 得到一个集合的迭代器
     // hasNext()：判断是否还有下一个元素
     while (iterator.hasNext()){
         // next作用：1.指针下移；2.将下移后的集合元素上的元素返回，类型是Object
         sout(iterator.next());
     }
     // 该while循环可以用itit快捷键生成（显示所有快捷键Ctrl + j）
     
     ```

     > 注意：在调用iterator.next()方法之前必须要调用iterator.hasNext()进行检测。若不调用，且下一条记录无效，直接调用iterator.next()会抛出NoSuchElementException异常。

   - 如果迭代器遍历一次后希望再次遍历，需要重置迭代器，即再运行一遍`iterator = coll.iterator();`，然后再迭代

2. for循环增强（在枚举和注解也讲过）

   - 增强for循环可以代替iterator迭代器，可以用于遍历**集合或数组**。其实就是简化版的iterator，底层仍然是迭代器。

   - 基本语法

     ```java
     for (元素类型 元素名: 集合或数组名){
         访问元素
     }
     // 快捷键I/iter
     ```



## 14.4 List 接口和常用方法

List 接口基本介绍：

- List接口是Collection 接口的子接口
- List集合类中的元素是有序的（即添加顺序和取出顺序一致），且可重复
- List集合类中的每个元素都有其对应的顺序索引，即支持索引。如ArrayList索引从0开始，依次递增。
- List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
- JDK API中List接口实现类又很多，常用的又ArrayList、LinkedList和Vector

---

List 接口的常用方法：

- `void add(int index, Object ele)`：在 index 位置插入 ele 元素，默认插在最后

  ```java
  List list = new ArrayList();
  list.add("张三丰");
  list.add("贾宝玉");
  //在 index = 1 的位置插入一个对象
  list.add(1, "Nina");
  ```

- `boolean addAll(int index, Collection eles)`:从 index 位置开始将 eles 中的所有元素

- `Object get(int index)`:获取指定 index 位置的元素

- `int indexOf(Object obj)`:返回 obj 在集合中首次出现的位置

- `int lastIndexOf(Object obj)`:返回 obj 在当前集合中末次出现的位置

- `Object remove(int index)`:移除指定 index 位置的元素，并返回此元素

- `Object set(int index, Object ele)`:设置指定 index 位置的元素为 ele , 相当于替换。index不存在则报错。

- `List subList(int fromIndex, int toIndex)`:返回从 fromIndex 到 toIndex位置的子集合，左闭右开。

---

List 的三种遍历方式（3个常用类皆可）：

- 使用iterator

- 使用增强for

- 使用普通for

  ```java
  for (int i = 0; i < list.size(); i++) {
      Object object = list.get(i);
      System.out.println(object);
  }
  ```





## 14.5 ArrayList 底层结构和源码分析 

ArrayList 的注意事项：

- ArrayList允许加入所有元素（元素可以重复），包括null
- ArrayList是用数组来实现数据存储的
- ArrayList基本等同于Vector，除了ArrayList是线程不安全的（但执行效率高）。因此，在多线程的情况下，不建议使用ArrayList

---

ArrayList 的底层操作机制源码分析(重点，难点)：

- ArrayList中维护了一个Object类型的数组elementData：`transient Object[] elementData;`，其中`transient`表示该属性不会被序列化（单词本身为短暂的，瞬间的意思）
- 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData的容量为0；第1次添加，则扩容elementData为10；如需再次扩容，则扩容elementData为1.5倍
- 如果使用的是指定大小的构造器，则初始elementData容量为指定大小；如需再次扩容，则扩容elementData为1.5倍

> 建议：自己debug一把ArrayList的创建和扩容流程

ArrayList扩容源码示意图：

![image-20220711211823343](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220711211823343.png)

- ensureExplicitCapacity中的modCount主要是为了防止有多个线程同时去修改它
- grow中扩容使用Array.copyOf是为了保留原有数据
- 注意：add中的size++是后++，先将值赋给原有size，在size++



## 14.6 Vector 底层结构和源码剖析 

Vector 的基本介绍：

- Vector类定义说明

  ```java
  public class Vector<E>
      extends AbstractList<E>
      implements List<E>, RandomAccess, Cloneable, java.io.Serializable
  ```

- Vector和ArrayList一样，底层也是一个数组对象`protected Object[] elementData;`

- Vector是线程同步的，即线程安全的，故Vector类的操作方法由synchronized关键字

- 在开发中，需要线程同步安全时，考虑使用Vector

---

Vector 和 ArrayList 的比较：

![image-20220711223535905](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220711223535905.png)

Vector扩容源码解读：

1. new Vector() 底层

   ```java
   public Vector() {
   	this(10);
   }
   
   //补充：如果是 Vector vector = new Vector(8);走的方法:
   public Vector(int initialCapacity) {
   	this(initialCapacity, 0);
   }
   ```

2. vector.add(i)

   ```java
   //1. 下面这个方法就添加数据到 vector 集合
   public synchronized boolean add(E e) {
       modCount++;
       ensureCapacityHelper(elementCount + 1);
       elementData[elementCount++] = e;
       return true;
   }
   
   //2. 确定是否需要扩容,条件 ： minCapacity - elementData.length>0
   private void ensureCapacityHelper(int minCapacity) {
       // overflow-conscious code
       if (minCapacity - elementData.length > 0)
       	grow(minCapacity);
   }
   
   //3. 如果需要的数组大小不够用，就扩容 , 扩容的算法newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity); 就是扩容两倍
   private void grow(int minCapacity) {
       // overflow-conscious code
       int oldCapacity = elementData.length;
       int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
       				capacityIncrement : oldCapacity);
       if (newCapacity - minCapacity < 0)
       	newCapacity = minCapacity;
       if (newCapacity - MAX_ARRAY_SIZE > 0)
       	newCapacity = hugeCapacity(minCapacity);
       elementData = Arrays.copyOf(elementData, newCapacity);
   }
   ```



## 14.7 LinkedList 底层结构 

LinkedList 的全面说明：

- LinkedList底层实现了双向链表和双端队列特点
- 可以任意添加元素（元素可以重复），包括null
- 线程不安全，没有实现同步

---

LinkedList 的底层操作机制：

- LinkedList 的底层维护了一个双向链表
- LinkedList中维护的两个属性first和last分别指向首节点和尾节点
- 每个节点（Node对象）里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表。
- 因此，LinkedList是元素添加和删除，不是通过数组完成的，相对来说效率较高

---

ArrayList 和 LinkedList 比较：



如何选择ArrayList 和 LinkedList：

- 如果查改多，选ArrayList
- 如果增删多，选 LinkedList
- 一般在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList
- 在一个项目中，根据业务灵活选择，也可能这样：一个模块使用ArrayList，另一个模块使用LinkedList，即根据业务选择

