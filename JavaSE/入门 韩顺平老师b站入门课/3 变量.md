## 3.2 变量介绍

变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示。通过变量名可以找到变量值。

![image-20220612201525526](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612201525526.png)

变量三个基本要素

- 类型
- 名称（对应地址）
- 值

使用基本步骤：

- 声明变量，如int a;
- 赋值，如a = 60;
- 使用System.out.println(a);

> 也可以一步到位int a = 60;

## 3.3 变量快速入门

## 3.4 变量使用注意事项

- 变量表示内存中的一个存储区域，不同的变量，类型不同，占用的空间大小不同
- 该区域有自己的名称（变量名）和类型（数据类型）
- 变量必须先声明，后使用，即有顺序
- 该区域的数据/值可以在**同一类型**范围内不断变化
- 变量在同一作用域内不能重名

> 作用域即作用的范围，一般一对{}即为一个作用域

- 变量 = 变量名 + 值 + 变量类型，请牢记。

## 3.5 程序中+号的使用

- 当左右两边都是数值型，做加法运算
- 当左右两边有一方为字符串，做拼接运算

> 注意是字符串，不是字符，如System.out.println("Hello" + 100)，输出为Hello100

- 运算顺序为从左到右

## 3.6 数据类型

Java是强类型的一种语言，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间（字节）。

> 基本数据类型在程序声明时用**小写**，否则容易报错。

![image-20220612135548636](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612135548636.png)

> String在Java中不是基本数据类型

## 3.7 整数类型

![image-20220612135754973](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612135754973.png)

> 对于比long更长的数字，使用BigInteger、BigDecimal

整形的使用细节：

- Java各整数类型有固定的范围和字段长度，不受具体OS（操作系统）的影响，以保证java程序的可移植性
- Java的整型常量（具体值）默认为int型，声明long型常量须后加l或L
- Java程序中变量常声明为**int型**，除非不足以表示大数，才使用long
- bit：计算机中的最小存储单位。byte：计算机基本存储单元，1 byte = 8 bit

## 3.8 浮点类型

![image-20220612153207928](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612153207928.png)

说明：

- 关于浮点数在机器中存放形式的简单说明，**浮点数=符号位+指数位+尾数**
- 尾数部分可能丢失，造成精度损失(小数都是**近似值**)

浮点型使用细节：

- Java浮点类型也有固定的范围和字段长度，不受具体OS的影响
- Java的浮点型常量（具体值）默认是double型，声明float型常量，需后加f或F
- 浮点型常量有两种表示形式：
  - 十进制数形式，如5.12，512.0f，.512（必须有小数点）
  - 科学计数法形式，如5.12E2（512.0），5.12e-2
- 通常情况下，应该使用double型，因为它比float型更精确（double型保留更多小数位数）
- 浮点数使用陷阱

> 例，
>
> double num11 = 2.7;
>
> double num12 = 8.1 、 3；
>
> 输出：
>
> num11 = 2.7
>
> num12 = 2.6666666667
>
> 这是计算机的问题，不是数学的问题。
>
> 因此，当我们对运算结果是小数的进行判断，要小心！应该以两个数的插值的绝对值**在某个精度范围内**判断，精度值由具体业务判断。
>
> 但是，如果是直接查询得到的小数或直接赋值，可以判断相等。

## 3.9 Java API文档

API（应用程序编程接口）是Java提供的基本编程接口。Java提供了大量基础类，因此提供了这些基础类相应的API文档。

Java类的组织形式

![image-20220612155953192](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612155953192.png)



## 3.10 字符类型

字符类型可以表示**单个字符**，字符类型是 char，char 是**两个字节**(可以存放汉字)，多个字符用String

快捷键补充：

> ctrl + shift + d 复制整行内容
>
> ctrl + shift + k 删除整行内容

字符串类型使用细节：

- 字符常量是用单引号括起来的单个字符
- Java中允许使用转义字符\来将其后的字符转变为特殊字符型常量
- 在Java中，char本质是一个整数，输出为unicode码对应的字符

- 可以直接给char赋一个整数，输出会按照对应的Unicode码输出，如97对应a
- char类型是可以进行运算的

> 注意与字符串拼接区分，如System.out.println('a' + 10)，输出为107

字符类型本质讨论

- 字符型存储到计算机中，需要将字符对应的码值（整数）找出来

> 存储：a => 码值97 => 二进制110 0001 => 存储
>
> 读取： 二进制110 0001 => 码值97 => a => 显示

- 字符和码值的对应关系是通过字符编码表决定的，即规定好的
- 字符编码表介绍
  - ASCII（一个字符由一个字节表示，一共有128个字符；实际上一个字节可以表示256个字符，但只用了128个。不能表示所有字符，仅对于英语国家足够。）
  - Unicode（一个字符由两个字节表示，最多为2的16次方65536，其中编码0-127的字符与ASCII一致，故Unicode兼容ASCII码。Unicode无乱码问题，但是字母汉字统一占两个字节，浪费空间）
  - UTF-8（互联网上使用最广的一种Unicode使用方式，是大小可变编码表，可以使用1-6个字节表示一个符号，根据不同符号而变化字节长度。字母使用1个字节，汉字使用3个字节）
  - GBK（可以表示汉字，且范围广，字母使用1个字节，汉字使用2个字节）
  - GB2312（可以表示汉字，GB2312 < GBK）
  - big5码（表示繁体中文）

## 3.14 布尔类型：boolean

只允许取true或false，无null，占一个字节，适用于逻辑运算。

一般用于程序流程控制：

- if
- while
- do-while
- for

使用细节说明：

- 不可以使用0或非0整数代替false或true

## 3.15 基本数据类型转换

## 3.15.1 自动类型转换

java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型

数据类型按精度大小排序：

![image-20220612165740625](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220612165740625.png)

自动类型转换注意和细节：

- 有多种类型数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，再进行运算

> 例如，
>
> int a = 10;
>
> float b = a + 1.1; // 会报错，应该改为double

- 当把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换

> 例如，int a = 1.1; // 会报错

- (byte, short)和char之间不会相互自动转换

> 例如，
>
> byte b1 = 10;
>
> b1 = b1 - 9; // 会报错
>
> char c1 = b1; // 会报错，short同理
>
> 当把数赋给byte时，先判断该数是否在范围（-128~127）内。
>
> 当把变量赋给byte时，先判断该类型是否一致，而不是看具体数字。
>
> 例如，
>
> int n2 = 1;
>
> byte b2 = n2;  // 会报错
>
> byte b3 = 1000; // 会报错

- byte, short, char三者可以计算，计算时先转为int类型

> 例如，
>
> byte b2 = 1;
>
> byte b3 = 2;
>
> short s1 = 3;
>
> int s = b2 + s1; // 成功
>
> byte b = b2 + b3; // 会报错

- boolean不参与转换
- 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型中

### 3.15.3 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上**强制转换符 ( )**，但可能造成精度降低或溢出，格外要注意。

> 例如，
>
> 1.  造成精度损失，结果为1
>
> ``` java
> int n1 = (int)1.9;
> System.out.println("n1=" + n1);
> ```
>
> 2. 造成数据溢出，结果为-48
>
> ```java
> int n2 = 2000;
> byte b1 = (byte)n2;
> System.out.println("b1=" + b1);
> ```
>
> 

强制类型转换细节说明：

- 当进行数据从大竞速到小精度，就需要使用到强制转换
- 强转符号只针对最近的操作数有效，往往使用**小括号**提升优先级

>  例如，
>
> ``` java
> int x = (int)10*3.5+6*1.5;// 只将10转为了int，导致编译错误： double -> int 
> int x = (int)(10*3.5+6*1.5);// 成功，(int)44.0 -> 44
> System.out.println(x);
> ```
>
> 

- char类型可以保存int常量值，但不能保存int变量值，需要强转

> 原理和byte一致
>
> 例如，
>
> ```java
> char c1 = 100; //ok
> int m = 100; //ok
> char c2 = m; //错误
> char c3 = (char)m; //ok
> System.out.println(c3);//100对应的字符, d字符
> ```
>
> 

- byte, short, char类型在进行运算时，当作int类型处理

## 3.17 基本数据类型和字符串的转换

在程序开发中，经常需要用到基本数据类型和String的互转。

- 基本数据类型转String类型

语法：将基本数据类型的值+”“即可

- String类型转基本数据类型

语法：通过基本类型的包装类调用parseXX方法即可（也可用于异常处理）

> 例如
>
> ```java
> int num1 = Integer.parseInt(s5);
> double num2 = Double.parseDouble(s5);
> float num3 = Float.parseFloat(s5);
> long num4 = Long.parseLong(s5);
> byte num5 = Byte.parseByte(s5);
> short num6 = Short.parseShort(s5);
> boolean b = Boolean.parseBoolean("true");
> ```

- 字符串转字符

语法：通过类似切片的方法s5.charAt(0)默认提取字符串第一个字符（下标从0开始）

> 例如，
>
> ```java
> System.out.println(s5.charAt(0));
> ```

### 3.17.2 转换注意事项

- 在将 String 类型转成基本数据类型时，要确保String类型能够转成有效的数据 
- 如果格式不正确，就会抛出异常，程序就会终止

> 在编译时不会报错，在执行时会抛出异常

