## 6.1 数组

数组可以存放多个**同一类型**的数据。数组也是一种数据类型，是**引用类型**。 

即：数组就是一组数据



## 6.2 数组的使用

使用方式1——动态初始化

- 数组的定义

``` java
数据类型[] 数组名/数据类型 数组名[] = new 数据类型[大小];
//例如，
int[] a/int a[] = new int[5]; 
// 创建存放5个int的数组，名字为a
// 在内存中，就分配了能存放5个元素值的空间
```

- 数组的引用/使用/访问/获取数组元素

```java
数组名[下标/索引/index]
```

- 利用循环输入来动态输入元素值

-----

使用方式2——动态初始化

- 先声明数组

```java
数据类型[] 数组名/数据类型 数组名[]; // 为null，尚未分配内存空间
```

- 创建数组

```java
数组名 = new 数据类型[大小]; // 分配内存空间，可以存放数据
```

- 利用循环输入来动态输入元素值

-----

使用方式3——静态初始化

- 初始化数组

一般数组个数较少，且已知元素值时使用。

```java
数据类型 数组名[] = {元素值1, 元素值2, ...};
// 或者
数据类型 数组名[] = new 数据类型[]{元素值1, 元素值2, ...};
```



P.S. 获取数组的长度——array.length



## 6.3 数组使用注意事项和细节 

1) 数组是多个相同类型数据的组合，实现对这些数据的统一管理 
2) 数组中的元素可以是**任何数据类型**，包括基本类型和引用类型，但是不能混用。
3) 数组创建后，如果没有赋值，有默认值（int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null）
4) 使用数组的步骤 
   1) 声明数组并开辟空间 
   2) 给数组各个元素赋值
   3) 使用数组 
5) 数组的下标是从 0 开始的。
6) 数组下标必须在指定范围内使用，否则报：下标越界异常
7) 数组属引用类型，数组型数据是对象(object) 



## 6.5 数组赋值机制 

1) 基本数据类型赋值为**值传递**，这个值就是具体的数据，而且相互不影响。 

   > 例如，
   >
   > ```java
   > int n1 = 2; 
   > int n2 = n1; // 不会影响n1
   > ```

2) 数组在默认情况下是**引用传递**，传递的值是**地址**。

> 例如，
>
> ```java
> int[] arr1 = {1,2,3};
> int[] arr2 = arr1; // arr2的变化会影响到arr1
> arr2[0] = 10; // 则arr1[0]也等于10
> ```



![image-20220616110523703](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220616110523703.png)

> 在内存中，只要分配了一个空间，就对应一个地址



## 6.7 数组反转

要求：把数组的元素内容反转。例如，{11,22,33,44,55,66} -> {66, 55,44,33,22,11}

思路分析：

- 通过找规律反转

  1. 把 arr[0] 和 arr[5] 进行交换 {66,22,33,44,55,11}

  2. 把 arr[1] 和 arr[4] 进行交换 {66,55,33,44,22,11}

  3. 把 arr[2] 和 arr[3] 进行交换 {66,55,44,33,22,11}

  4. 一共要交换 3 次 = arr.length / 2

  5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]

- 使用逆序赋值方式（自己想到的）

  1. 先创建一个新的数组 arr2 ,大小 arr.length

  2. 逆序遍历 arr ,将 每个元素拷贝到 arr2的元素中(顺序拷贝)
     - 建议增加一个循环变量顺序遍历 j -> 0 -> 5

  3. 让 arr 指向 arr2数据空间, 此时 arr原来的数据空间就没有变量引用，会通过垃圾回收机制当做垃圾，销毁

> 方法1代码更简洁，且空间复杂度更小



## 6.9 排序的介绍

排序是将多个数据，依指定的顺序进行排列的过程。

排序的分类：

- 内部排序: 指将需要处理的所有数据都加载到**内部存储器**中进行排序。包括交换式排序法、选择式排序法和插入式排序法
- 外部排序法： 数据量过大，无法全部加载到内存中，需要**借助外部存储**进行排序。包括合并排序法和直接合并排序法。



## 6.10 冒泡排序法 

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

案例演示：

![image-20220616153803886](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220616153803886.png)

P.S. 冒泡排序算法优化

使用计数器计算每次交换时的计算次数，若某次交换时计数为0，说明已经排好序，直接跳出排序，输出结果。



## 6.12 查找

在 java 中，我们常用的查找有两种: 

1) 顺序查找
2) 二分查找【二分法，我们放在算法讲解】

P.S. 经典编程小技巧

定义 int index = -1;

若查找到相应位置，则index = 相应位置；若没有，则通过index == -1 返回相应信息。



## 6.13 多维数组-二维数组

二维数组的每个元素是一维数组。

二维数组使用方式

使用方式 1: 动态初始化

- 定义

```java
类型[][] 数组名=new 类型[大小][大小]
```

- 遍历赋值

```java
for (int i = 1; i < arr.length; i++){ // arr.length：获取二维数组构成元素（一维数组）的个数
    for (int j = 1; j < arr[i].length; j++){ // arr[i].length：获取第i个一维数组元素个数
        arr[i][j] = ...;
        // System.out.print(arr[i][j] + " "); // 输出
    }
}
```

- 内存机制

![image-20220616171642810](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220616171642810.png)

---

使用方式 2: 动态初始化

- 先声明数组

```java
数据类型[][] 数组名/数据类型 数组名[][];
```

- 再定义(开辟空间)

```java
数组名=new 数据类型[大小][大小]; // 分配内存空间，可以存放数据
```

- 遍历赋值 & 内存机制（同上）

--------

- 使用方式 3: 动态初始化-列数不确定

在Java中，允许一维数组元素个数不同。

- 定义

```java
类型[][] 数组名=new 类型[大小][]
```

- 遍历赋值

在遍历时，需要给每个一维数组开辟对应长度的空间，例如arr[i] = new int[i + 1]

- 内存机制

在定义时只定义了一个元素为空的二维数组，每个元素（一维数组）都为null，没有开辟空间/指向地址

-----

- 静态初始化

```java
数据类型[][] 数组名 = {{一维数组1}, {一维数组2}, ...}
// 一维数组只有一个值也要写{}
```

- 遍历输出（同上）



## 6.16 二维数组使用细节和注意事项 

1) 一维数组的声明方式有: int[] x 或者 int x[] 
2) 二维数组的声明方式有: int[][] y 或者 int[] y[] 或者 int y[][] 
3) 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。

>  注意：尽量一个问题一段代码，清清楚楚的写，不要混在一起，看着方便，其实很混乱



