## 7.1 类与对象

一个养猫猫问题：张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。还有一只叫小花,今年 100 岁,花色。请编写一个程序，当用户 输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示 张老太没有这只猫。

使用现有技术解决：

1) 单独的定义变量解决

   不利于数据的管理(你把一只猫的信息拆解)

2) 使用数组解决 

   (1)数据类型体现不出来

   (2) 只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确

   (3) 不能体现猫的行为

java 设计者 引入类与对象(OOP) ，根本原因就是现有的技术，不能完美的解决新的新的需求。

一个程序就是一个世界，有很多事物(对象[属性, 行为])

---

类与对象的关系：

- 类是抽象的，概念的，代表一类事物，即是数据类型
- 对象是具体的，实际的，代表一个具体事物, 即是一个具体的实例
- 类是对象的模板，对象是类的一个个体，对应一个实例

示意图：

![image-20220616214730171](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220616214730171.png)



----------

如何创建对象：

先声明再创建： 

- Cat cat ; //声明对象 
- cat cat = new Cat(); //创建

直接创建 

- Cat cat = new Cat();

补充：匿名对象（只能用一次，用完就销毁）

- new Test()

--------

属性/成员变量/字段：

属性定义语法（同变量）：

```java
访问修饰符 属性类型 属性名; 
```

- 访问修饰符： 控制属性的访问范围 

- 有四种访问修饰符 public, protected, 默认, private

如何访问属性：

```java
对象名.属性名; 
// 例如
cat.name; 
cat.age; 
cat.color; 
```



注意事项和细节说明：

- 从概念或叫法上看： 成员变量 = 属性 = field(字段) ，即成员变量是用来表示属性的。

- 属性是类的一个组成部分，一般是基本数据类型，也可是引用类型(对象，数组)。

- 属性如果不赋值，有默认值，规则和数组一致。
  - 具体说: int 0，short 0, byte 0, long 0, float 0.0，double 0.0，char \u0000， boolean false，String null 



-------------

Java 内存的结构分析 

1) 栈： 一般存放基本数据类型(局部变量) 
2) 堆： 存放对象(Cat cat , 数组等) 
3) 方法区：常量池(常量，比如字符串)， 类加载信息



对象在内存中存在形式（重要，必须搞清楚）：

- 字符串也是一个引用类型，因此会把数据放在方法区的常量池中。
  - 从jdk1.7开始，字符串常量池已经从方法区移到堆中了
  - 而jdk1.8及以后，方法区又从堆内存中剥离出来，但实现方式与之前的永久代不同，这时的方法区被叫做元空间，常量池就存储在元空间中。
- 对象名（对象引用） ≠ 对象，例如 Person p1 = new Person();，其中p1是对象名，new Person()创建的对象空间（数据）才是真正的对象

![image-20220616220558292](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220616220558292.png)



类和对象的内存分配机制(重要)：

![image-20220616232929005](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220616232929005.png)



----

Java 创建对象的流程简单分析

```java
Person p = new Person();
p.name = “jack”;
p.age = 10;
```

- 先加载 Person 类信息(属性和方法信息, 只会加载**一次**，若再次创建对象，则不会加载了) 
- 在堆中分配空间, 进行默认初始化(看规则)
- 把地址赋给 p，p就指向对象
- 进行指定初始化， 比如 p.name =”jack” 



## 7.2 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。

如何定义方法：

- 形参列表：表示成员方法输入
- 返回数据类型：表示成员方法输出, void 表示没有返回值
- 方法主体：表示为了实现某一功能代码块
- return 语句不是必须的

```java
访问修饰符 返回数据类型 方法名（形参列表..） {//方法体
    语句；
    return 返回值;
}
```

方法写好后后，如果不去调用，不会输出。

调用方法：

```JAVA
// 例如
Person p1 = new person;
p1.speak();
```



----

方法的调用机制原理：(重要!-示意图!!!) 

![image-20220617101503750](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220617101503750.png)



------

成员方法的好处：

1) 提高代码的复用性 
2) 可以将实现的细节封装起来，然后供其他用户来调用即可 



----

注意事项和使用细节：

- 访问修饰符

  - 作用是控制方法使用的范围
  - 如果不写默认访问，有四种: public, protected, 默认, private

- 返回数据类型

  - 一个方法最多有一个返回值 [思考，如何返回多个结果 返回数组 ]
  - 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 
  - 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型**一致或兼容** 
  - 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return 

- 方法名

  - 遵循驼峰命名法，最好见名知义，表达出该功能的意思即可

- 形参列表

  - 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开
  - 参数类型可以为任意类型，包含基本类型或引用类型(数组，对象) 
  - 调用带参数的方法时，一定对应着参数列表传入**相同类型或兼容类型**的参数！
  - 方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，称为实参，实参和形参的类型要**一致或兼容，个数、顺序必须一致**！

- 方法体

  - 里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但是不能再定义方法，即方法不能嵌套定义。

- 方法调用

  - 同一个类中的方法调用：直接调用即可
  - 跨类中的方法A类调用B，类方法：需要先定义一个调用对象，然后通过对象名.方法名(参数)调用

  > 例如，
  >
  > ```java
  > B b = new B();
  > b.hi();
  > ```
  >
  > 

  - 特别说明：跨类的方法调用和方法的访问修饰符相关，后面会详细讲

## 7.3 成员方法传参机制(非常非常重要)

- 基本数据类型的传参机制：

​	基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！

​	因为两个栈是独立的空间，互不影响。

- 引用数据类型的传参机制

​	引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！

> 如果传参变化绕不出来了，记得用内存分析法画图分析



## 7.4 方法递归调用(非常非常重要，比较难)

递归就是方法自己调用自己,每次调用时传入不同的变量。递归有助于编程者解决复杂问题,同时可以让代码变得简洁。

示意图：

![image-20220617163503626](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220617163503626.png)

递归重要规则：

- 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
- 方法的局部变量是独立的，不会相互影响，如n变量
- 如果方法中使用的是引用类型变量，就会共享该引用类型的数据
- 递归必须向退出递归的条件逼近，否则就是无限递归，出现栈溢出错误
- 当一个方法执行完毕，或遇到return，就会返回。遵守谁调用，就将结果返回给谁的原则；当方法执行完毕或者返回时，该方法也就执行完毕。



## 7.5 方法重载(OverLoad)

java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致。

比如：System.out.println();，括号中形参可以为int、char、boolean...

----

重载的好处： 

1) 减轻了起名的麻烦 
2) 减轻了记名的麻烦

-------

注意事项和使用细节：

1. 方法名：必须相同
2. 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）
3. 返回类型、修饰符：无要求



## 7.6 可变参数

java 允许将同一个类中多个**同名同功能但参数个数不同**的方法，封装成一个方法。 这里就可以通过可变参数实现。

基本语法：

```java
访问修饰符 返回类型 方法名(数据类型... 形参名) {
}
```

注意事项和使用细节：

- 可变参数的实参可以为0个或任意多个
- 可变参数的实参可以为数组，即可以传入数组
- 可变参数的本质就是数组，即传入方法内部的值是数组，可以使用数组的属性和方法
- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
- 一个形参列表中只可能出现一个可变参数



## 7.7 作用域

面向对象中，变量作用域是非常重要的知识点，要深刻掌握变量作用域。

- 在Java编程中，主要的变量就是属性（成员变量）和局部变量
- 局部变量一般是指在成员方法中定义的变量
- Java中作用域的分类
  - 全局变量：也就是属性，作用域为整个类体
  - 局部变量：也就是除了属性之外的局部变量，作用域为**定义它的代码块**中
- 全局变量可以不赋值，直接使用，因为有默认值；局部变量必须赋值后才能使用，因为没有默认值

------

注意事项和细节使用：

- 属性和局部变量可以重名，访问时遵循就近原则
- 在同一作用域中，比如在同一个成员方法中，两个局部变量不能重名
- 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。
- 作用域范围不用
  - 全局变量：可以被本类使用或（通过对象调用）被其他类使用
  - 局部变量：只能在本类中对应的方法中使用
- 修饰符不同
  - 全局变量可以加修饰符
  - 局部变量不可以加修饰符



## 7.8 构造方法/构造器

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是**完成对新对象的初始化**。

基本语法：

```java
[修饰符] 方法名(形参列表){
	方法体;
}
```

说明： 

1) 构造器的修饰符可以默认， 也可以是 public protected private 
2) 构造器没有返回值，也不能写void
3) 方法名 和类名字必须一样 
4) 参数列表 和 成员方法一样的规则 
5) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化，即构造器的调用由系统完成

------

注意事项和使用细节：

- 一个类可以定义多个不同的构造器，叫构造器重载
- 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），如Dog (){}

> 可以使用javap指令进行反编译
>
> ```java
> javap Dog.class // .class可以不写
> ```
>
> 

- 一旦定义了自己的构造器，默认构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，比如用Dog (){}声明一下



## 7.9 对象创建的流程分析

以一段代码为例：

```java
class Person{
    int age = 90;
    String name;
    Person (String n, int a){
        name = n;
        age = a;
    }
}
Person p = new Person("Terry", 20);
```



- 先加载 Person 类信息到方法区，只会加载一次

- 在堆中分配对象空间, 会得到一个地址

- 根据规则对对象进行初始化

  - 默认初始化，这里age = 0，name = null

  - 显式初始化，这里age = 90，name = null

  - 构造器初始化，这里age = 20, name = Terry

    > Terry这个字符串保存在方法区的常量池中，通过地址指向堆的空间

- 把地址赋给 p（对象名/对象引用），p就指向对象



## 7.10 this 关键字

如果我们构造器的形参，能够直接写成属性名，就更好了。但是出现了一个问题，若直接写成属性名，根据变量的作用域原则，构造器的形参（如name ）是局部变量，而不是属性。

因此，引出this关键字来解决。改成this.name = name即可，this.name表示当前对象的属性name。

Java虚拟机会给每个对象分配this，代表当前对象。简单的说，哪个对象调用，this就代表哪个对象。

示意图：

![image-20220619153904238](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220619153904238.png)

P.S. 简单获取对象情况（由于代码是在虚拟机中运行的，并不是实际地址）：hashCode方法，返回hash code，类似对象的地址，如this.hashCode()、dog1.hashCode()



---

注意事项和使用细节：

1) this 关键字可以用来访问本类的**属性、方法、构造器** 

2) this 用于区分当前类的属性和局部变量 

3) 访问成员方法的语法：**this.方法名(参数列表);**

4. 访问构造器语法：**this(参数列表);** 

   > 注意：只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)
   >
   > 例如，
   >
   > ```java
   > public T(){
   >     // 这里去访问T(String name, int age)
   >     this("Nina", 22);
   >     System.out.println("T()");
   > }
   > public T(String name, int age){
   >     System.out.println("T(String name, int age)");
   > }
   > ```
   >
   > 

5) this 不能在类定义的外部使用，只能在**类定义的方法中**使用。



P.S. 在写代码时，先完成正常业务，然后再考虑代码健壮性，参考Homework01.java

题目要求：编写类A01，定义方法max，实现求某个double数组的最大值，并返回。

```java
public class Homework01{
	public static void main(String[] args){
		double[] arr = {6.3,7.8,9.66,8.55,69.5,78.4,15.2};
		A01 test = new A01();
		Double max = test.doubleMax(arr); // 注意返回的是Double类！
		// 这里考虑的是代码的健壮性
		if (max != null){
			System.out.println(max);
		} else{
			System.out.println("输入有误，数组不能为null，或{}");
		}
		
	}
}

class A01{
	public Double doubleMax(double[] arr){
		if (arr != null && arr.length > 0){ // 这里考虑的是代码的健壮性
			double max = arr[0];
			for (int i = 1; i < arr.length; i++){
				if (arr[i] > max){
					max = arr[i];
				}
			}
			return max;
		} else{
			return null; // 这里考虑的是代码的健壮性，返回的是Double对象，可以为空，因此不报错
		}
	}
}
```



P.P.S. 随机整数

```java
import java.util.Random;
Random r = new Random();
int num = r.nextInt(n); // 返回0~n-1的随机整数
```

