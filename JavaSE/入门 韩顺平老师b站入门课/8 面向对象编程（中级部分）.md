## 8.1 IDEA（集成开发环境）

IDEA 常用快捷键：

1) 删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d 
2) 复制当前行, 自己配置 ctrl + alt + 向下光标 
3) 补全代码 alt + /
4) 添加注释和取消注释 ctrl + /
5) 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可
6) 快速格式化代码 ctrl + alt + L 
7) 快速运行程序 自己定义 F5 

> 使用这个快捷键时，记得先配置主类；若无法配置，先手动运行一次，再使用快捷键

8. 生成构造器等 alt + insert [提高开发效率] 
9. 查看一个类的层级关系 ctrl + H [学继承后，非常有用] 
10. 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] 
11. 自动的分配变量名 , 通过 在后面加 .var[老师最喜欢的，注意只能在主类使用] 



------

自定义模板

通过file -> settings -> editor -> Live Template查看有哪些模板快捷键/自己增加模板[模板可以高效的完成开发，提高速度]

常用模板快捷键：

- main
- fori
- sout



## 8.4 包

包的本质实际上就是创建不同文件夹/目录来保存类文件。

包基本语法：

```java
package com.hspedu;
```

package关键字表示打包，com.hspedu表示包名。

------

包的三大作用：

1. 区分相同名字的类
2. 当类很多时，可以很好的管理类
3. 控制访问范围

-----

包的命名

命名规则：只能包含数字，字母，下划线，小圆点，但不能用数字开头。不能是关键字或保留字

命名规范：一般是小写字母+小圆点，一般是com.公司名.项目名.业务模块名

---

常用的包：

一个包下，包含很多的类，java 中常用的包有: 

1) java.lang.* //lang 包是基本包，默认引入，不需要再引入. 
2) java.util.* //util 包，系统提供的工具包, 工具类，使用 Scanner 
3) java.net.* //网络包，网络开发 
4) java.awt.* //是做 java 的界面开发，GUI

---

如何引入包

我们引入一个包的主要目的是要使用该包下的类。

语法： import 包;

```java
import java.util.Scanner; // 只引入一个类Scanner
import java.util.*; // 将java.util包所有类都引入
```

建议：需要使用到哪个类，就导入哪个类，不建议使用*导入类



包中的类在程序中的两种引用方法：

1. 先import，再直接new

```java
import com.xiaoqiang.Dog;
Dog dog = new Dog();
```

2. 带包名一起new

```java
com.xiaoming.Dog dog1 = new com.xiaoming.Dog();
```



-------

注意事项和使用细节：

1. package的作用是**声明当前类所在的包**，需要放在类的**最上面**，一个类中最多只有一个package
2. import指令位置放在package下面，在类定义前面，可以有多句且没有顺序要求



## 8.5 访问修饰符 

基本介绍 

java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）: 

1) 公开级别:用 public 修饰，对外公开 
2) 受保护级别:用 protected 修饰,对子类和同一个包中的类公开 
3) 默认级别:没有修饰符号,向同一个包的类（包括子类）公开
4) 私有级别:用 private 修饰,只有类本身可以访问,不对外公开

![image-20220626120448297](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220626120448297.png)

---------

使用的注意事项：

1. 修饰符可以用来修饰类中的属性，成员方法及类
2. 成员方法的访问规则和属性完全一样
3. 只有默认和public才能修饰类，并且遵循上述访问权限的特点

> 一个x.java文件中，只有一个public类

4. 关于在子类中的访问权限，待下回分解



##  8.6 面向对象编程三大特征

面向对象编程有三大特征：封装、继承和多态。

### 8.6.1 封装

封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只用通过被授权的操作[方法]，才能对数据进行操作

-----

封装的理解和好处：

1. 隐藏实现细节：方法（连接数据库）<--调用（传入参数...）
2. 可以对数据进行验证，保证安全合理

-------

封装实现步骤（三步）：

1. 将属性进行私有化private，让外部不能直接修改属性
2. 提供一个公共的(public)set方法，用于对属性判断并赋值

```java
public voud setXxx(类型 参数名){ // Xxx表示某个属性
    // 加入数据验证的业务逻辑
    属性 = 参数名;
}
```

3. 提供一个公共的(public)get方法，用于获取属性值

```java
public 数据类型 getXxx(){ // 权限判断, Xxx表示某个属性
    return xx;
}
```

> 将构造器和 setXxx 结合，这样仍然可以验证数据



### 8.6.2 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 **extends** 来声明继承父类即可。

示意图：

![image-20220626212928170](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220626212928170.png)

> 子类可能不止一层的关系，比如上图D类是A类的子类。

继承的基本语法：

```java
class 子类 extends 父类{
}
```

说明：

1. 子类会自动拥有父类定义的属性和方法

> 即使父类的属性和方法为私有，子类仍分配了内存保存这些私有属性与方法

2. 父类又叫超类、基类，字类又叫派生类

-----------

继承给编程带来的便利：

1) 代码的复用性提高了 
2) 代码的扩展性和维护性提高了 

------

继承的深入讨论/细节问题：

1) 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问 

> 对于默认属性，若父类和子类在同一个包中，则可以直接访问

2. 子类必须调用父类的构造器， 完成父类的初始化 

> 因为在子类的构造器中会有默认语句super();默认调用父类的无参构造器

3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) 
5. super 在使用时，必须放在构造器第一行，且super 只能在构造器中使用
6. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 

> 即在子类的构造器中，两者不能同时显式出现，若不写或指定super();，则为super();，若指定了this();，就为this();

3. java 所有类都是 Object 类的子类, Object 是所有类的基类

4. 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 

5. 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 

   > 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】

6. 不能滥用继承，子类和父类之间必须满足 is-a的逻辑关系

----

继承的本质分析

当子类对象创建好后，建立查找关系，按照查找关系来返回数据：

1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息，若不能访问，则直接报错
3. 如果子类没有这个属性，就看父类有没有这个属性（如果父类有该属性，并且可以访问，则返回信息，若不能访问，则直接报错）

> 若父类属性不能访问，但是其上级父类的该属性可以访问，还是会报错，不会跳上上级进行访问

4. 如果父类没有，就按照3的原则，继续找上级父类i，直到Object

---------

子类创建的内存布局

![image-20220627100509472](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220627100509472.png)



### 8.6.2.1 super关键字

super 代表父类的引用，用于访问父类的属性、方法、构造器。

基本语法：

- 访问父类的属性，但不能访问父类的private属性

```java
super.属性名;
```

- 访问父类的方法，不能访问父类的private方法

```java
super.方法名(参数列表);
```

- 访问父类得到构造器

```java
super(参数列表); // 只能放在构造器第一句，只能出现一句！
```



---

super 给编程带来的便利/细节：

- 调用父类构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）
- 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果

> - 找子类没有重名方法 cal 时(cal() 和 this.cal())，顺序是: 
>
> (1)先找本类，如果有，则调用 
>
> (2)如果没有，则找父类(如果有，并可以调用，则调用) 
>
> (3)如果父类没有，则继续找父类的父类，整个规则是一样的，直到 Object 类
>
> 提示：如果查找方法的过程中，找到了，但是不能访问， 则报错 cannot access；如果查找方法的过程中，没有找到，则提示方法不存在
>
> - 找子类没有重名方法 cal (super.call()) 的顺序是直接查找父类，其他的规则一样
> - 找子类有重名的方法cal时，cal() 和 this.cal()获取子类对应方法，super.call()获取父类对应方法
>
> 以上为方法调用规则，属性调用规则也是一样的

- super的访问不限于直接父类，如果爷爷类和本类有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中有同名的成员，使用super访问遵循就近原则。

----

super 和 this 的比较：

![image-20220627124247823](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220627124247823.png)



#### 8.6.2.2 方法重写/覆盖(override)

简单的说，方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法。

> 这里的子类和父类可能是多层关系。

-----

注意事项和使用细节：

- 子类方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样
- 子类方法的返回类型和父类方法的返回类型一致，或是父类返回类型的子类

> 例如，父类为`public Object getInfo()`，子类为`public String getInfo()`

- 子类方法不能缩小父类方法的访问权限（public>protected>默认>private）

> 例如，父类为`void sayOk()`，子类为`public void sayOk()`

------

方法的重写和重载的比较：

![image-20220627124845266](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220627124845266.png)



### 8.6.3 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

多态的具体体现：

1) 方法的多态：重写和重载就体现多态
2) 对象的多态 (核心，困难，重点)

重要的几句话：

* 一个对象的编译类型和运行类型可以不一致

> 即一个父类引用可以指向子类的一个对象，如Animal animal = new Dog();，其编译类型为Animal，运行类型为Dog

* 编译类型在定义对象时就确定了，不能改变
* 运行类型是可以变化的
* 编译类型看定义时 = 的左边，运行类型看 = 的右边

---

注意事项和细节讨论：

- 多态的前提是：两个对象(类)存在继承关系

- 多态的向上转型

  - 本质：父类的引用指向了子类的对象
  - 语法：父类类型 引用名 = new 子类类型();
  - 调用规则
    - 编译类型看左边，运行类型看右边。
    - 可以调用父类中的所有成员（需遵守访问权限）
    - 不能调用子类中特有成员（因为在编译阶段，能调用哪些成员，是由编译类型来决定的）
    - 最终运行效果看子类（运行类型）的具体体现（因为运行阶段从子类开始查找方法，然后调用，规则与前面讲的方法调用规则一致）

- 多态的向下转型

  - 语法：子类类型 引用名 = (子类类型) 父类引用;
  - 只能强转父类的引用，不能强转父类的对象，即能够改变指向该对象地址的引用，但地址本身是不变的

  - 要求父类的引用必须指向的是当前目标类型的对象（向下转型就必须先线上转型）

  > 例如，
  >
  > ```java
  > Animal animal  = new Cat(); // 这里父类的引用指向的是当前目标类型的对象Cat
  > Cat cat = (Cat) animal; 
  > /*
  > 这里内存进行的操作为：
  > animal保持指向Cat对象不变，增加cat指向Cat对象。
  > 由于cat编译类型和运行类型都为Cat类，故可以调用Cat类中的所有成员；
  > 而animal的编译类型为Animal，运行类型为Cat，不能调用Cat类中的所有成员。
  > */
  > Dog dog = (Dog) animal; // 这是错的，相当于把Cat强转变为Dog
  > ```
  >
  > 

  - 当向下转型后，可以调用子类类型中所有的成员

- 属性没有重写之说！属性的值看编译类型

- instanceOf 比较操作符，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

> 对于比较操作符 == ，比较的是两个对象的地址

例题：

![image-20220627175949293](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220627175949293.png)

错误原因：没有从向上转型和向下转型的角度思考后面几个语句

---------

**Java 重要特性: 动态绑定机制(非常非常重要)** 

- 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
- 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

---

多态的应用 

1) 多态数组 

   数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。

   例如，

   应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法. 

   应用实例升级：如何调用子类特有的方法，比如 Teacher 有一个 teach , Student 有一个 study 怎么调用？

   ```java
   // 只写了main方法的内部内容
   // 动态数组的定义
   Person[] persons = new Person[5];
   persons[0] = new Person("jack", 20);
   persons[1] = new Student("mary", 18, 100);
   persons[2] = new Student("smith", 19, 30.1);
   persons[3] = new Teacher("scott", 30, 20000);
   persons[4] = new Teacher("king", 50, 25000);
   
   //循环遍历多态数组，调用 say
   for (int i = 0; i < persons.length; i++) {
       //注意：person[i] 编译类型是 Person ,运行类型是是根据实际情况有 JVM 来判断
       System.out.println(persons[i].say());//动态绑定机制
       //这里使用 类型判断 + 向下转型
       if(persons[i] instanceof Student) {//判断 person[i] 的运行类型是不是 Student
           ((Student)persons[i]).study();
       } else if(persons[i] instanceof Teacher) {
           Teacher teacher = (Teacher)persons[i];
           teacher.teach(); //上一种更简洁，这种更直观
       } else if(persons[i] instanceof Person){
       	//System.out.println("你的类型有误, 请自己检查...");
       } else {
       	System.out.println("你的类型有误, 请自己检查...");
   }
   ```

   

2) 多态参数

   方法定义的形参为父类类型，实参类型允许为子类类型。

   例如，

   定义员工类Employee，包含姓名和月工资[private]，记忆计算年工资getAnnual的方法。普通员工和经理继承了员工，经历多了奖金bonus属性和管理manage方法，普通员工多了work方法，普通员工和经历了要求分别重写getAnnual方法

   测试类中添加一个方法showEmpAnnual(Employee e)，实现获取任何员工对象的年工资,并在 main 方法中调用该方法 [e.getAnnual()]

   测试类中添加一个方法，testWork,如果是普通员工，则调用 work 方法，如果是经理，则调用 manage 方法

   ```java
   // 只写了main方法的内部内容
   public class PloyParameter {
       public static void main(String[] args) {
           Worker tom = new Worker("tom", 2500);
           Manager milan = new Manager("milan", 5000, 200000);
           PloyParameter ployParameter = new PloyParameter(); // 调用main方法中的方法，需要定义主类对象
           ployParameter.showEmpAnnual(tom);
           ployParameter.showEmpAnnual(milan);
           ployParameter.testWork(tom);
           ployParameter.testWork(milan);
   	} // 这里main方法结束了，定义测试方法需要在main方法外
       
       // 实现获取任何员工对象的年工资[e.getAnnual()]
       public void showEmpAnnual(Employee e) {
       	System.out.println(e.getAnnual());//动态绑定机制
       }
       // 如果是普通员工，则调用 work 方法，如果是经理，则调用 manage 方法
       public void testWork(Employee e) {
           if(e instanceof Worker) {
               ((Worker) e).work();//向下转型操作
           } else if(e instanceof Manager) {
               ((Manager) e).manage();//向下转型操作
           } else {
               System.out.println("不做处理...");
           }
       }
   }
   
   ```



## 8.7 Object类详解

### 8.7.1 equals 方法

==和 equals 的对比：

- ==：是一个比较运算符，既可以判断基本类型，又可以判断引用类型
  - 如果判断基本类型，判断值是否相等
  - 如果判断引用类型，判断地址是否相等，即判断是不是同一个对象
- equals：是Object类中的方法，只能判断引用类型。默认判断地址是否相等，子类往往重写该方法，用于判断内容是否相等，如Integer，String

例题：

```java
Integer integer1 = new Integer(1000);
Integer integer2 = new Integer(1000);
System.out.println(integer1 == integer2);//false
System.out.println(integer1.equals(integer2));//true
```

P.S. 当代码只需要一条if语句（无else if 和else）且return为boolean时，可以直接简化为return 判断条件



### 8.7.2 hashCode 方法

返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。 

实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 Java 编程语言不需要这种实现技巧。） 

小结: 

- 提高具有哈希结构的容器的效率！
- 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 
- 两个引用，如果指向的是不同对象，则哈希值是不一样的 
- 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址
- 后面在集合中， hashCode 如果需要的话，也会重写



### 8.7.3 toString 方法

默认返回：全类名（包名+类名）+@+哈希值的十六进制 

子类往往重写 toString 方法，用于返回对象的属性信息：

- 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式
- 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()



### 8.7.4 finalize 方法

- 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些**释放资源**的操作。
- 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。这时程序员就可以在finalize中写自己的业务逻辑代码（如释放资源：数据库连接，或打开文件）；如果程序员不重写 finalize，那么就会调用 Object 类的 finalize。
- 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制。

> 提示： 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试



### 8.7.5 getClass方法

用来查看对象的运行类型。



## 8.13 断点调试(debug)

提示：在断点调试的过程中，是运行状态，是以对象的运行类型来执行的

断点调试能帮助我们查看Java底层源代码是执行过程，从而提高程序员的java水平

断点调试的快捷键：

- F7：跳入方法内 
- F8：逐行执行代码
- shift+F8: 跳出方法
- F9：继续执行到下一个断点
- Ctrl+F5：开始debug
- Ctrl+F2：停止debug

小技巧：

- 将光标放在某个变量上，可以看到最新的数据
- 断点可以在debug过程中，动态的下断点
- 在自己的程序和系统程序（源码）中，都可以下断点，但是实际执行过程中会根据业务逻辑来判断是否进入这个断点，这可以帮助程序员判断程序走的业务逻辑线

