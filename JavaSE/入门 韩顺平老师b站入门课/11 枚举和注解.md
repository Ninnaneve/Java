## 11.3 枚举 

P.S. 在代码开头增加个人信息：打开IDEA，点`File -> Settings -> File and Code Templates -> Includes`。在代码块写入个人信息然后点击`Apply`。

枚举对应英文(enumeration, 简写 enum) ，是一组常量的集合。 

这里可以理解为：枚举属于一种**特殊的类**，里面只包含一组有限的特定的对象。

----

枚举的二种实现方式：

1) 自定义类实现枚举 
2) 使用 enum 关键字实现枚举

---

自定义类实现枚举：

1. 将构造器私有化，防止直接new

2. 可以提供 get 方法，但是不要提供 set方法，以防止程序被修改，因为枚举对象通常为只读

3. 在类内部直接创建固定对象，使用`final + static`共同修饰，实现底层优化，例如`public final static SPRING = new Season("春天", "温暖");`

   >final和static搭配使用不会导致类加载

   - 枚举对象名通常使用全部大写，与常量的命名规范相同
   - 枚举对象根据需要，也可以有多个属性

4. 调用：类.对象



---

使用 enum 关键字实现枚举：

1. 使用关键字 enum 替代 class，上述1、2点仍要求
2. 直接使用`常量名(实参列表)`定义，如上例`public static final Season SPRING = new Season("春天", "温暖") `变为`SPRING("春天", "温暖") `，但原有的`public final static`约束还是不变的，本质也还是类的一个对象实例
3. 如果有多个常量(对象)， 使用 ,号间隔，如`SPRING("春天", "温暖"), WINTER("冬天", "寒冷"), AUTUMN("秋天", "凉爽"), SUMMER("夏天", "炎热");`
4. 如果使用 enum 来实现枚举，要求将定义常量对象写在最前面
5. 调用：类.对象

---

enum 关键字实现枚举注意事项：

1. 当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类（使用 javap 工具可以证明）

   ![image-20220703160118398](https://cdn.jsdelivr.net/gh/Ninnaneve/my_pic@main/image-20220703160118398.png)

2. 必须知道枚举对象调用的是哪个构造器，例如，`SPRING("春天", "温暖")`为传入两个字符串的构造器

3. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略

4. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾

---

enum 常用方法应用实例：

1. toString：返回当前对象名，子类可以重写该方法，用于返回对象的属性信息 

2. name：返回当前对象名（常量名），子类中不能重写 

   > 其底层机制：在常量对象创建时调用了父类的构造方法，把自己的名字传给了父类的name属性

3. ordinal：返回当前对象的位置号，默认从 0 开始

4. values：返回当前定义的枚举对象构成的数组，源码将该方法隐藏起来，javap反编译可见

   > 补充：增强for循环
   >
   > ```java
   > Season[] values = Season.value();
   > for (Season season: values){ 
   >     // 依次从values中取一个值赋给season，取出完毕则退出循环，类似Python
   > }
   > ```
   >
   > 

5. valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！

   > 例如，
   >
   > ```java
   > Season autumn = Season.valueof("AUTUMN"); // 和之前创建的AUTUMN对象是同一个对象！
   > ```
   >
   > 

6) compareTo：比较两个枚举常量，比较的就是编号，返回的是编号相减的结果（前-后）

---

enum 实现接口：

1. 使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制

2. 枚举类和普通类一样，可以实现接口，如下形式。 

   ```java
   enum 类名 implements 接口 1，接口 2{}
   ```

   

## 11.12 注解的理解 

1) 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。 
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 
3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置。

---

基本的 Annotation 介绍： 

使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。

三个基本的 Annotation: 

1. @Override: 限定某个方法，是重写父类方法，该注解**只能用于方法中**

   - `@Override`表示指定重写父类的方法（从编译层面验证），如果父类没有相应方法，则会报错

   - 如果不写`@Override`注解，父类仍有该方法，仍然构成重写

   - 如果写了`@Override`注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过；如果没有构成重写，则编译错误

   - 查看`@Override`的注解源码：

     ```java
     // @Target是修饰注解的注解，称为元注解
     @Target(ElementType.METHOD) // 说明只能修饰方法
     @Retention(RetentionPolicy.SOURCE)
     public @interface Override {
     }
     ```

     > 补充说明：`@interface`不是`interface`，而是注解类，是JDK5.0之后加入的

2. @Deprecated: 用于表示某个程序元素(类, 方法等)已过时

   - `@Deprecated`表示不在推荐使用，但是仍然可以使用

   - 可以修饰方法、类、字段、包、参数等等

   - 查看`@Deprecated`注解类的源

     ```java
     @Documented
     @Retention(RetentionPolicy.RUNTIME)
     @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) // 可以修饰方法、类、字段、包、参数等等
     public @interface Deprecated {
     }
     ```

   - `@Deprecated`的作用是可以做到新旧版本的兼容和过渡

3) @SuppressWarnings: 抑制编译器警告

   - 当我们不希望看到警告时，可以使用 `@SuppressWarnings` 注解来抑制警告
   
   - 在{""} 中，可以写入你希望抑制(不显示)警告信息
   
   - 可以指定的警告类型请查看附加文件（SuppressWarning 中的属性介绍以及属性说明.txt），一劳永逸可填写all
   
   - 作用范围与放置位置有关，比如放在main方法，那么抑制警告的范围就是main方法，但通常会放置具体的语句, 方法, 类上
   
   - 生成`@SuppressWarnings`时，直接点击左侧的黄色提示，就可以选择
   
   - 说明各种值
   
     - unchecked：忽略没有检查的警告
     - rawtypes：忽略没有指定泛型的警告（传参时没有指定泛型的错误警告）
     - unused：忽略没有使用某个变量的错误警告
   
   - 查看`@SuppressWarnings`的注解源码
   
     ```java
     @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
     @Retention(RetentionPolicy.SOURCE)
     public @interface SuppressWarnings {
     String[] value(); // 说明可以传入多个抑制参数
     }
     ```



## 11.15 JDK 的元 Annotation(元注解， 了解）

基本介绍：

JDK 的元 Annotation 用于修饰其他 Annotation 

元注解： 本身作用不大，只要在看源码时知道是干什么的就行

-----

元注解的种类 (使用不多，了解，不用深入研究）：

1) Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME
2) Target // 指定注解可以在哪些地方使用 
3) Documented //指定该注解是否会在 javadoc 体现 
4) Inherited //子类会继承父类注解

----

### 11.15.1 @Retention

说明：

只能用于修饰一个 Annotation 定义，用于指定该 Annotation 可以保留多长时间，@Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值。

@Retention 的三种值：

1) RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释
2) RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中，当运行 Java 程序时, JVM 不会保留注解。 这是默认值。
3) RetentionPolicy.RUNTIME：编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解。程序可以通过反射获取该注解。

---

### 11.15.2 @Target

用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量，包含了可以用于修饰的程序元素名。

---

### 11.15.3 @Documented

用于指定被该元Annotation修饰的Annotation类将被javadoc工具同去成文档，即在生成文档时，可以看到该注解。

说明：定义为@Documented的注解必须设置@Retention值为RUNTIME

----

### 11.15.4 @Inherited

被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。

说明：实际应用中，使用较少，了解即可。



